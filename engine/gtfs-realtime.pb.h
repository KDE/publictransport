// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gtfs-realtime.proto

#ifndef PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
#define PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace transit_realtime {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();

class FeedMessage;
class FeedHeader;
class FeedEntity;
class TripUpdate;
class TripUpdate_StopTimeEvent;
class TripUpdate_StopTimeUpdate;
class VehiclePosition;
class Alert;
class TimeRange;
class Position;
class TripDescriptor;
class VehicleDescriptor;
class EntitySelector;
class TranslatedString;
class TranslatedString_Translation;

enum FeedHeader_Incrementality {
  FeedHeader_Incrementality_FULL_DATASET = 0,
  FeedHeader_Incrementality_DIFFERENTIAL = 1
};
bool FeedHeader_Incrementality_IsValid(int value);
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MIN = FeedHeader_Incrementality_FULL_DATASET;
const FeedHeader_Incrementality FeedHeader_Incrementality_Incrementality_MAX = FeedHeader_Incrementality_DIFFERENTIAL;
const int FeedHeader_Incrementality_Incrementality_ARRAYSIZE = FeedHeader_Incrementality_Incrementality_MAX + 1;

const ::google::protobuf::EnumDescriptor* FeedHeader_Incrementality_descriptor();
inline const ::std::string& FeedHeader_Incrementality_Name(FeedHeader_Incrementality value) {
  return ::google::protobuf::internal::NameOfEnum(
    FeedHeader_Incrementality_descriptor(), value);
}
inline bool FeedHeader_Incrementality_Parse(
    const ::std::string& name, FeedHeader_Incrementality* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FeedHeader_Incrementality>(
    FeedHeader_Incrementality_descriptor(), name, value);
}
enum TripUpdate_StopTimeUpdate_ScheduleRelationship {
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED = 0,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED = 1,
  TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA = 2
};
bool TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(int value);
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
const TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
const int TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
inline const ::std::string& TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), value);
}
inline bool TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(
    const ::std::string& name, TripUpdate_StopTimeUpdate_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripUpdate_StopTimeUpdate_ScheduleRelationship>(
    TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor(), name, value);
}
enum VehiclePosition_VehicleStopStatus {
  VehiclePosition_VehicleStopStatus_INCOMING_AT = 0,
  VehiclePosition_VehicleStopStatus_STOPPED_AT = 1,
  VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO = 2
};
bool VehiclePosition_VehicleStopStatus_IsValid(int value);
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN = VehiclePosition_VehicleStopStatus_INCOMING_AT;
const VehiclePosition_VehicleStopStatus VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
const int VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE = VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehiclePosition_VehicleStopStatus_descriptor();
inline const ::std::string& VehiclePosition_VehicleStopStatus_Name(VehiclePosition_VehicleStopStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehiclePosition_VehicleStopStatus_descriptor(), value);
}
inline bool VehiclePosition_VehicleStopStatus_Parse(
    const ::std::string& name, VehiclePosition_VehicleStopStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_VehicleStopStatus>(
    VehiclePosition_VehicleStopStatus_descriptor(), name, value);
}
enum VehiclePosition_CongestionLevel {
  VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL = 0,
  VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY = 1,
  VehiclePosition_CongestionLevel_STOP_AND_GO = 2,
  VehiclePosition_CongestionLevel_CONGESTION = 3,
  VehiclePosition_CongestionLevel_SEVERE_CONGESTION = 4
};
bool VehiclePosition_CongestionLevel_IsValid(int value);
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MIN = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
const VehiclePosition_CongestionLevel VehiclePosition_CongestionLevel_CongestionLevel_MAX = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
const int VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE = VehiclePosition_CongestionLevel_CongestionLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* VehiclePosition_CongestionLevel_descriptor();
inline const ::std::string& VehiclePosition_CongestionLevel_Name(VehiclePosition_CongestionLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    VehiclePosition_CongestionLevel_descriptor(), value);
}
inline bool VehiclePosition_CongestionLevel_Parse(
    const ::std::string& name, VehiclePosition_CongestionLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<VehiclePosition_CongestionLevel>(
    VehiclePosition_CongestionLevel_descriptor(), name, value);
}
enum Alert_Cause {
  Alert_Cause_UNKNOWN_CAUSE = 1,
  Alert_Cause_OTHER_CAUSE = 2,
  Alert_Cause_TECHNICAL_PROBLEM = 3,
  Alert_Cause_STRIKE = 4,
  Alert_Cause_DEMONSTRATION = 5,
  Alert_Cause_ACCIDENT = 6,
  Alert_Cause_HOLIDAY = 7,
  Alert_Cause_WEATHER = 8,
  Alert_Cause_MAINTENANCE = 9,
  Alert_Cause_CONSTRUCTION = 10,
  Alert_Cause_POLICE_ACTIVITY = 11,
  Alert_Cause_MEDICAL_EMERGENCY = 12
};
bool Alert_Cause_IsValid(int value);
const Alert_Cause Alert_Cause_Cause_MIN = Alert_Cause_UNKNOWN_CAUSE;
const Alert_Cause Alert_Cause_Cause_MAX = Alert_Cause_MEDICAL_EMERGENCY;
const int Alert_Cause_Cause_ARRAYSIZE = Alert_Cause_Cause_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_Cause_descriptor();
inline const ::std::string& Alert_Cause_Name(Alert_Cause value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_Cause_descriptor(), value);
}
inline bool Alert_Cause_Parse(
    const ::std::string& name, Alert_Cause* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Cause>(
    Alert_Cause_descriptor(), name, value);
}
enum Alert_Effect {
  Alert_Effect_NO_SERVICE = 1,
  Alert_Effect_REDUCED_SERVICE = 2,
  Alert_Effect_SIGNIFICANT_DELAYS = 3,
  Alert_Effect_DETOUR = 4,
  Alert_Effect_ADDITIONAL_SERVICE = 5,
  Alert_Effect_MODIFIED_SERVICE = 6,
  Alert_Effect_OTHER_EFFECT = 7,
  Alert_Effect_UNKNOWN_EFFECT = 8,
  Alert_Effect_STOP_MOVED = 9
};
bool Alert_Effect_IsValid(int value);
const Alert_Effect Alert_Effect_Effect_MIN = Alert_Effect_NO_SERVICE;
const Alert_Effect Alert_Effect_Effect_MAX = Alert_Effect_STOP_MOVED;
const int Alert_Effect_Effect_ARRAYSIZE = Alert_Effect_Effect_MAX + 1;

const ::google::protobuf::EnumDescriptor* Alert_Effect_descriptor();
inline const ::std::string& Alert_Effect_Name(Alert_Effect value) {
  return ::google::protobuf::internal::NameOfEnum(
    Alert_Effect_descriptor(), value);
}
inline bool Alert_Effect_Parse(
    const ::std::string& name, Alert_Effect* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Alert_Effect>(
    Alert_Effect_descriptor(), name, value);
}
enum TripDescriptor_ScheduleRelationship {
  TripDescriptor_ScheduleRelationship_SCHEDULED = 0,
  TripDescriptor_ScheduleRelationship_ADDED = 1,
  TripDescriptor_ScheduleRelationship_UNSCHEDULED = 2,
  TripDescriptor_ScheduleRelationship_CANCELED = 3,
  TripDescriptor_ScheduleRelationship_REPLACEMENT = 5
};
bool TripDescriptor_ScheduleRelationship_IsValid(int value);
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN = TripDescriptor_ScheduleRelationship_SCHEDULED;
const TripDescriptor_ScheduleRelationship TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX = TripDescriptor_ScheduleRelationship_REPLACEMENT;
const int TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE = TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX + 1;

const ::google::protobuf::EnumDescriptor* TripDescriptor_ScheduleRelationship_descriptor();
inline const ::std::string& TripDescriptor_ScheduleRelationship_Name(TripDescriptor_ScheduleRelationship value) {
  return ::google::protobuf::internal::NameOfEnum(
    TripDescriptor_ScheduleRelationship_descriptor(), value);
}
inline bool TripDescriptor_ScheduleRelationship_Parse(
    const ::std::string& name, TripDescriptor_ScheduleRelationship* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TripDescriptor_ScheduleRelationship>(
    TripDescriptor_ScheduleRelationship_descriptor(), name, value);
}
// ===================================================================

class FeedMessage : public ::google::protobuf::Message {
 public:
  FeedMessage();
  virtual ~FeedMessage();
  
  FeedMessage(const FeedMessage& from);
  
  inline FeedMessage& operator=(const FeedMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedMessage& default_instance();
  
  void Swap(FeedMessage* other);
  
  // implements Message ----------------------------------------------
  
  FeedMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedMessage& from);
  void MergeFrom(const FeedMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .transit_realtime.FeedHeader header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::transit_realtime::FeedHeader& header() const;
  inline ::transit_realtime::FeedHeader* mutable_header();
  
  // repeated .transit_realtime.FeedEntity entity = 2;
  inline int entity_size() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::transit_realtime::FeedEntity& entity(int index) const;
  inline ::transit_realtime::FeedEntity* mutable_entity(int index);
  inline ::transit_realtime::FeedEntity* add_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
      entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
      mutable_entity();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::transit_realtime::FeedHeader* header_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity > entity_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeedMessage* default_instance_;
};
// -------------------------------------------------------------------

class FeedHeader : public ::google::protobuf::Message {
 public:
  FeedHeader();
  virtual ~FeedHeader();
  
  FeedHeader(const FeedHeader& from);
  
  inline FeedHeader& operator=(const FeedHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedHeader& default_instance();
  
  void Swap(FeedHeader* other);
  
  // implements Message ----------------------------------------------
  
  FeedHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedHeader& from);
  void MergeFrom(const FeedHeader& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef FeedHeader_Incrementality Incrementality;
  static const Incrementality FULL_DATASET = FeedHeader_Incrementality_FULL_DATASET;
  static const Incrementality DIFFERENTIAL = FeedHeader_Incrementality_DIFFERENTIAL;
  static inline bool Incrementality_IsValid(int value) {
    return FeedHeader_Incrementality_IsValid(value);
  }
  static const Incrementality Incrementality_MIN =
    FeedHeader_Incrementality_Incrementality_MIN;
  static const Incrementality Incrementality_MAX =
    FeedHeader_Incrementality_Incrementality_MAX;
  static const int Incrementality_ARRAYSIZE =
    FeedHeader_Incrementality_Incrementality_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Incrementality_descriptor() {
    return FeedHeader_Incrementality_descriptor();
  }
  static inline const ::std::string& Incrementality_Name(Incrementality value) {
    return FeedHeader_Incrementality_Name(value);
  }
  static inline bool Incrementality_Parse(const ::std::string& name,
      Incrementality* value) {
    return FeedHeader_Incrementality_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required string gtfs_realtime_version = 1;
  inline bool has_gtfs_realtime_version() const;
  inline void clear_gtfs_realtime_version();
  static const int kGtfsRealtimeVersionFieldNumber = 1;
  inline const ::std::string& gtfs_realtime_version() const;
  inline void set_gtfs_realtime_version(const ::std::string& value);
  inline void set_gtfs_realtime_version(const char* value);
  inline void set_gtfs_realtime_version(const char* value, size_t size);
  inline ::std::string* mutable_gtfs_realtime_version();
  
  // optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
  inline bool has_incrementality() const;
  inline void clear_incrementality();
  static const int kIncrementalityFieldNumber = 2;
  inline ::transit_realtime::FeedHeader_Incrementality incrementality() const;
  inline void set_incrementality(::transit_realtime::FeedHeader_Incrementality value);
  
  // optional uint64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedHeader)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* gtfs_realtime_version_;
  static const ::std::string _default_gtfs_realtime_version_;
  int incrementality_;
  ::google::protobuf::uint64 timestamp_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeedHeader* default_instance_;
};
// -------------------------------------------------------------------

class FeedEntity : public ::google::protobuf::Message {
 public:
  FeedEntity();
  virtual ~FeedEntity();
  
  FeedEntity(const FeedEntity& from);
  
  inline FeedEntity& operator=(const FeedEntity& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeedEntity& default_instance();
  
  void Swap(FeedEntity* other);
  
  // implements Message ----------------------------------------------
  
  FeedEntity* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeedEntity& from);
  void MergeFrom(const FeedEntity& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional bool is_deleted = 2 [default = false];
  inline bool has_is_deleted() const;
  inline void clear_is_deleted();
  static const int kIsDeletedFieldNumber = 2;
  inline bool is_deleted() const;
  inline void set_is_deleted(bool value);
  
  // optional .transit_realtime.TripUpdate trip_update = 3;
  inline bool has_trip_update() const;
  inline void clear_trip_update();
  static const int kTripUpdateFieldNumber = 3;
  inline const ::transit_realtime::TripUpdate& trip_update() const;
  inline ::transit_realtime::TripUpdate* mutable_trip_update();
  
  // optional .transit_realtime.VehiclePosition vehicle = 4;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 4;
  inline const ::transit_realtime::VehiclePosition& vehicle() const;
  inline ::transit_realtime::VehiclePosition* mutable_vehicle();
  
  // optional .transit_realtime.Alert alert = 5;
  inline bool has_alert() const;
  inline void clear_alert();
  static const int kAlertFieldNumber = 5;
  inline const ::transit_realtime::Alert& alert() const;
  inline ::transit_realtime::Alert* mutable_alert();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.FeedEntity)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  bool is_deleted_;
  ::transit_realtime::TripUpdate* trip_update_;
  ::transit_realtime::VehiclePosition* vehicle_;
  ::transit_realtime::Alert* alert_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeedEntity* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeEvent : public ::google::protobuf::Message {
 public:
  TripUpdate_StopTimeEvent();
  virtual ~TripUpdate_StopTimeEvent();
  
  TripUpdate_StopTimeEvent(const TripUpdate_StopTimeEvent& from);
  
  inline TripUpdate_StopTimeEvent& operator=(const TripUpdate_StopTimeEvent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate_StopTimeEvent& default_instance();
  
  void Swap(TripUpdate_StopTimeEvent* other);
  
  // implements Message ----------------------------------------------
  
  TripUpdate_StopTimeEvent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate_StopTimeEvent& from);
  void MergeFrom(const TripUpdate_StopTimeEvent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 delay = 1;
  inline bool has_delay() const;
  inline void clear_delay();
  static const int kDelayFieldNumber = 1;
  inline ::google::protobuf::int32 delay() const;
  inline void set_delay(::google::protobuf::int32 value);
  
  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional int32 uncertainty = 3;
  inline bool has_uncertainty() const;
  inline void clear_uncertainty();
  static const int kUncertaintyFieldNumber = 3;
  inline ::google::protobuf::int32 uncertainty() const;
  inline void set_uncertainty(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeEvent)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 delay_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 uncertainty_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TripUpdate_StopTimeEvent* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate_StopTimeUpdate : public ::google::protobuf::Message {
 public:
  TripUpdate_StopTimeUpdate();
  virtual ~TripUpdate_StopTimeUpdate();
  
  TripUpdate_StopTimeUpdate(const TripUpdate_StopTimeUpdate& from);
  
  inline TripUpdate_StopTimeUpdate& operator=(const TripUpdate_StopTimeUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate_StopTimeUpdate& default_instance();
  
  void Swap(TripUpdate_StopTimeUpdate* other);
  
  // implements Message ----------------------------------------------
  
  TripUpdate_StopTimeUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate_StopTimeUpdate& from);
  void MergeFrom(const TripUpdate_StopTimeUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TripUpdate_StopTimeUpdate_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship SKIPPED = TripUpdate_StopTimeUpdate_ScheduleRelationship_SKIPPED;
  static const ScheduleRelationship NO_DATA = TripUpdate_StopTimeUpdate_ScheduleRelationship_NO_DATA;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripUpdate_StopTimeUpdate_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
  }
  static inline const ::std::string& ScheduleRelationship_Name(ScheduleRelationship value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(const ::std::string& name,
      ScheduleRelationship* value) {
    return TripUpdate_StopTimeUpdate_ScheduleRelationship_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional uint32 stop_sequence = 1;
  inline bool has_stop_sequence() const;
  inline void clear_stop_sequence();
  static const int kStopSequenceFieldNumber = 1;
  inline ::google::protobuf::uint32 stop_sequence() const;
  inline void set_stop_sequence(::google::protobuf::uint32 value);
  
  // optional string stop_id = 4;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 4;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  
  // optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
  inline bool has_arrival() const;
  inline void clear_arrival();
  static const int kArrivalFieldNumber = 2;
  inline const ::transit_realtime::TripUpdate_StopTimeEvent& arrival() const;
  inline ::transit_realtime::TripUpdate_StopTimeEvent* mutable_arrival();
  
  // optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
  inline bool has_departure() const;
  inline void clear_departure();
  static const int kDepartureFieldNumber = 3;
  inline const ::transit_realtime::TripUpdate_StopTimeEvent& departure() const;
  inline ::transit_realtime::TripUpdate_StopTimeEvent* mutable_departure();
  
  // optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
  inline bool has_schedule_relationship() const;
  inline void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 5;
  inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship schedule_relationship() const;
  inline void set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate.StopTimeUpdate)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 stop_sequence_;
  ::std::string* stop_id_;
  static const ::std::string _default_stop_id_;
  ::transit_realtime::TripUpdate_StopTimeEvent* arrival_;
  ::transit_realtime::TripUpdate_StopTimeEvent* departure_;
  int schedule_relationship_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TripUpdate_StopTimeUpdate* default_instance_;
};
// -------------------------------------------------------------------

class TripUpdate : public ::google::protobuf::Message {
 public:
  TripUpdate();
  virtual ~TripUpdate();
  
  TripUpdate(const TripUpdate& from);
  
  inline TripUpdate& operator=(const TripUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TripUpdate& default_instance();
  
  void Swap(TripUpdate* other);
  
  // implements Message ----------------------------------------------
  
  TripUpdate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripUpdate& from);
  void MergeFrom(const TripUpdate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TripUpdate_StopTimeEvent StopTimeEvent;
  typedef TripUpdate_StopTimeUpdate StopTimeUpdate;
  
  // accessors -------------------------------------------------------
  
  // required .transit_realtime.TripDescriptor trip = 1;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 1;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  
  // optional .transit_realtime.VehicleDescriptor vehicle = 3;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 3;
  inline const ::transit_realtime::VehicleDescriptor& vehicle() const;
  inline ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  
  // repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
  inline int stop_time_update_size() const;
  inline void clear_stop_time_update();
  static const int kStopTimeUpdateFieldNumber = 2;
  inline const ::transit_realtime::TripUpdate_StopTimeUpdate& stop_time_update(int index) const;
  inline ::transit_realtime::TripUpdate_StopTimeUpdate* mutable_stop_time_update(int index);
  inline ::transit_realtime::TripUpdate_StopTimeUpdate* add_stop_time_update();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
      stop_time_update() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
      mutable_stop_time_update();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TripUpdate)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate > stop_time_update_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TripUpdate* default_instance_;
};
// -------------------------------------------------------------------

class VehiclePosition : public ::google::protobuf::Message {
 public:
  VehiclePosition();
  virtual ~VehiclePosition();
  
  VehiclePosition(const VehiclePosition& from);
  
  inline VehiclePosition& operator=(const VehiclePosition& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehiclePosition& default_instance();
  
  void Swap(VehiclePosition* other);
  
  // implements Message ----------------------------------------------
  
  VehiclePosition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehiclePosition& from);
  void MergeFrom(const VehiclePosition& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef VehiclePosition_VehicleStopStatus VehicleStopStatus;
  static const VehicleStopStatus INCOMING_AT = VehiclePosition_VehicleStopStatus_INCOMING_AT;
  static const VehicleStopStatus STOPPED_AT = VehiclePosition_VehicleStopStatus_STOPPED_AT;
  static const VehicleStopStatus IN_TRANSIT_TO = VehiclePosition_VehicleStopStatus_IN_TRANSIT_TO;
  static inline bool VehicleStopStatus_IsValid(int value) {
    return VehiclePosition_VehicleStopStatus_IsValid(value);
  }
  static const VehicleStopStatus VehicleStopStatus_MIN =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MIN;
  static const VehicleStopStatus VehicleStopStatus_MAX =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_MAX;
  static const int VehicleStopStatus_ARRAYSIZE =
    VehiclePosition_VehicleStopStatus_VehicleStopStatus_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  VehicleStopStatus_descriptor() {
    return VehiclePosition_VehicleStopStatus_descriptor();
  }
  static inline const ::std::string& VehicleStopStatus_Name(VehicleStopStatus value) {
    return VehiclePosition_VehicleStopStatus_Name(value);
  }
  static inline bool VehicleStopStatus_Parse(const ::std::string& name,
      VehicleStopStatus* value) {
    return VehiclePosition_VehicleStopStatus_Parse(name, value);
  }
  
  typedef VehiclePosition_CongestionLevel CongestionLevel;
  static const CongestionLevel UNKNOWN_CONGESTION_LEVEL = VehiclePosition_CongestionLevel_UNKNOWN_CONGESTION_LEVEL;
  static const CongestionLevel RUNNING_SMOOTHLY = VehiclePosition_CongestionLevel_RUNNING_SMOOTHLY;
  static const CongestionLevel STOP_AND_GO = VehiclePosition_CongestionLevel_STOP_AND_GO;
  static const CongestionLevel CONGESTION = VehiclePosition_CongestionLevel_CONGESTION;
  static const CongestionLevel SEVERE_CONGESTION = VehiclePosition_CongestionLevel_SEVERE_CONGESTION;
  static inline bool CongestionLevel_IsValid(int value) {
    return VehiclePosition_CongestionLevel_IsValid(value);
  }
  static const CongestionLevel CongestionLevel_MIN =
    VehiclePosition_CongestionLevel_CongestionLevel_MIN;
  static const CongestionLevel CongestionLevel_MAX =
    VehiclePosition_CongestionLevel_CongestionLevel_MAX;
  static const int CongestionLevel_ARRAYSIZE =
    VehiclePosition_CongestionLevel_CongestionLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CongestionLevel_descriptor() {
    return VehiclePosition_CongestionLevel_descriptor();
  }
  static inline const ::std::string& CongestionLevel_Name(CongestionLevel value) {
    return VehiclePosition_CongestionLevel_Name(value);
  }
  static inline bool CongestionLevel_Parse(const ::std::string& name,
      CongestionLevel* value) {
    return VehiclePosition_CongestionLevel_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .transit_realtime.TripDescriptor trip = 1;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 1;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  
  // optional .transit_realtime.VehicleDescriptor vehicle = 8;
  inline bool has_vehicle() const;
  inline void clear_vehicle();
  static const int kVehicleFieldNumber = 8;
  inline const ::transit_realtime::VehicleDescriptor& vehicle() const;
  inline ::transit_realtime::VehicleDescriptor* mutable_vehicle();
  
  // optional .transit_realtime.Position position = 2;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 2;
  inline const ::transit_realtime::Position& position() const;
  inline ::transit_realtime::Position* mutable_position();
  
  // optional uint32 current_stop_sequence = 3;
  inline bool has_current_stop_sequence() const;
  inline void clear_current_stop_sequence();
  static const int kCurrentStopSequenceFieldNumber = 3;
  inline ::google::protobuf::uint32 current_stop_sequence() const;
  inline void set_current_stop_sequence(::google::protobuf::uint32 value);
  
  // optional string stop_id = 7;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 7;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  
  // optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
  inline bool has_current_status() const;
  inline void clear_current_status();
  static const int kCurrentStatusFieldNumber = 4;
  inline ::transit_realtime::VehiclePosition_VehicleStopStatus current_status() const;
  inline void set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value);
  
  // optional uint64 timestamp = 5;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 5;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
  inline bool has_congestion_level() const;
  inline void clear_congestion_level();
  static const int kCongestionLevelFieldNumber = 6;
  inline ::transit_realtime::VehiclePosition_CongestionLevel congestion_level() const;
  inline void set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.VehiclePosition)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::transit_realtime::TripDescriptor* trip_;
  ::transit_realtime::VehicleDescriptor* vehicle_;
  ::transit_realtime::Position* position_;
  ::google::protobuf::uint32 current_stop_sequence_;
  ::std::string* stop_id_;
  static const ::std::string _default_stop_id_;
  int current_status_;
  ::google::protobuf::uint64 timestamp_;
  int congestion_level_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VehiclePosition* default_instance_;
};
// -------------------------------------------------------------------

class Alert : public ::google::protobuf::Message {
 public:
  Alert();
  virtual ~Alert();
  
  Alert(const Alert& from);
  
  inline Alert& operator=(const Alert& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Alert& default_instance();
  
  void Swap(Alert* other);
  
  // implements Message ----------------------------------------------
  
  Alert* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Alert& from);
  void MergeFrom(const Alert& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Alert_Cause Cause;
  static const Cause UNKNOWN_CAUSE = Alert_Cause_UNKNOWN_CAUSE;
  static const Cause OTHER_CAUSE = Alert_Cause_OTHER_CAUSE;
  static const Cause TECHNICAL_PROBLEM = Alert_Cause_TECHNICAL_PROBLEM;
  static const Cause STRIKE = Alert_Cause_STRIKE;
  static const Cause DEMONSTRATION = Alert_Cause_DEMONSTRATION;
  static const Cause ACCIDENT = Alert_Cause_ACCIDENT;
  static const Cause HOLIDAY = Alert_Cause_HOLIDAY;
  static const Cause WEATHER = Alert_Cause_WEATHER;
  static const Cause MAINTENANCE = Alert_Cause_MAINTENANCE;
  static const Cause CONSTRUCTION = Alert_Cause_CONSTRUCTION;
  static const Cause POLICE_ACTIVITY = Alert_Cause_POLICE_ACTIVITY;
  static const Cause MEDICAL_EMERGENCY = Alert_Cause_MEDICAL_EMERGENCY;
  static inline bool Cause_IsValid(int value) {
    return Alert_Cause_IsValid(value);
  }
  static const Cause Cause_MIN =
    Alert_Cause_Cause_MIN;
  static const Cause Cause_MAX =
    Alert_Cause_Cause_MAX;
  static const int Cause_ARRAYSIZE =
    Alert_Cause_Cause_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Cause_descriptor() {
    return Alert_Cause_descriptor();
  }
  static inline const ::std::string& Cause_Name(Cause value) {
    return Alert_Cause_Name(value);
  }
  static inline bool Cause_Parse(const ::std::string& name,
      Cause* value) {
    return Alert_Cause_Parse(name, value);
  }
  
  typedef Alert_Effect Effect;
  static const Effect NO_SERVICE = Alert_Effect_NO_SERVICE;
  static const Effect REDUCED_SERVICE = Alert_Effect_REDUCED_SERVICE;
  static const Effect SIGNIFICANT_DELAYS = Alert_Effect_SIGNIFICANT_DELAYS;
  static const Effect DETOUR = Alert_Effect_DETOUR;
  static const Effect ADDITIONAL_SERVICE = Alert_Effect_ADDITIONAL_SERVICE;
  static const Effect MODIFIED_SERVICE = Alert_Effect_MODIFIED_SERVICE;
  static const Effect OTHER_EFFECT = Alert_Effect_OTHER_EFFECT;
  static const Effect UNKNOWN_EFFECT = Alert_Effect_UNKNOWN_EFFECT;
  static const Effect STOP_MOVED = Alert_Effect_STOP_MOVED;
  static inline bool Effect_IsValid(int value) {
    return Alert_Effect_IsValid(value);
  }
  static const Effect Effect_MIN =
    Alert_Effect_Effect_MIN;
  static const Effect Effect_MAX =
    Alert_Effect_Effect_MAX;
  static const int Effect_ARRAYSIZE =
    Alert_Effect_Effect_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Effect_descriptor() {
    return Alert_Effect_descriptor();
  }
  static inline const ::std::string& Effect_Name(Effect value) {
    return Alert_Effect_Name(value);
  }
  static inline bool Effect_Parse(const ::std::string& name,
      Effect* value) {
    return Alert_Effect_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // repeated .transit_realtime.TimeRange active_period = 1;
  inline int active_period_size() const;
  inline void clear_active_period();
  static const int kActivePeriodFieldNumber = 1;
  inline const ::transit_realtime::TimeRange& active_period(int index) const;
  inline ::transit_realtime::TimeRange* mutable_active_period(int index);
  inline ::transit_realtime::TimeRange* add_active_period();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
      active_period() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
      mutable_active_period();
  
  // repeated .transit_realtime.EntitySelector informed_entity = 5;
  inline int informed_entity_size() const;
  inline void clear_informed_entity();
  static const int kInformedEntityFieldNumber = 5;
  inline const ::transit_realtime::EntitySelector& informed_entity(int index) const;
  inline ::transit_realtime::EntitySelector* mutable_informed_entity(int index);
  inline ::transit_realtime::EntitySelector* add_informed_entity();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
      informed_entity() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
      mutable_informed_entity();
  
  // optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
  inline bool has_cause() const;
  inline void clear_cause();
  static const int kCauseFieldNumber = 6;
  inline ::transit_realtime::Alert_Cause cause() const;
  inline void set_cause(::transit_realtime::Alert_Cause value);
  
  // optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
  inline bool has_effect() const;
  inline void clear_effect();
  static const int kEffectFieldNumber = 7;
  inline ::transit_realtime::Alert_Effect effect() const;
  inline void set_effect(::transit_realtime::Alert_Effect value);
  
  // optional .transit_realtime.TranslatedString url = 8;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 8;
  inline const ::transit_realtime::TranslatedString& url() const;
  inline ::transit_realtime::TranslatedString* mutable_url();
  
  // optional .transit_realtime.TranslatedString header_text = 10;
  inline bool has_header_text() const;
  inline void clear_header_text();
  static const int kHeaderTextFieldNumber = 10;
  inline const ::transit_realtime::TranslatedString& header_text() const;
  inline ::transit_realtime::TranslatedString* mutable_header_text();
  
  // optional .transit_realtime.TranslatedString description_text = 11;
  inline bool has_description_text() const;
  inline void clear_description_text();
  static const int kDescriptionTextFieldNumber = 11;
  inline const ::transit_realtime::TranslatedString& description_text() const;
  inline ::transit_realtime::TranslatedString* mutable_description_text();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.Alert)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange > active_period_;
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector > informed_entity_;
  int cause_;
  int effect_;
  ::transit_realtime::TranslatedString* url_;
  ::transit_realtime::TranslatedString* header_text_;
  ::transit_realtime::TranslatedString* description_text_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Alert* default_instance_;
};
// -------------------------------------------------------------------

class TimeRange : public ::google::protobuf::Message {
 public:
  TimeRange();
  virtual ~TimeRange();
  
  TimeRange(const TimeRange& from);
  
  inline TimeRange& operator=(const TimeRange& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TimeRange& default_instance();
  
  void Swap(TimeRange* other);
  
  // implements Message ----------------------------------------------
  
  TimeRange* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TimeRange& from);
  void MergeFrom(const TimeRange& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline ::google::protobuf::uint64 start() const;
  inline void set_start(::google::protobuf::uint64 value);
  
  // optional uint64 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::uint64 end() const;
  inline void set_end(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TimeRange)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 start_;
  ::google::protobuf::uint64 end_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TimeRange* default_instance_;
};
// -------------------------------------------------------------------

class Position : public ::google::protobuf::Message {
 public:
  Position();
  virtual ~Position();
  
  Position(const Position& from);
  
  inline Position& operator=(const Position& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Position& default_instance();
  
  void Swap(Position* other);
  
  // implements Message ----------------------------------------------
  
  Position* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Position& from);
  void MergeFrom(const Position& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required float latitude = 1;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 1;
  inline float latitude() const;
  inline void set_latitude(float value);
  
  // required float longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline float longitude() const;
  inline void set_longitude(float value);
  
  // optional float bearing = 3;
  inline bool has_bearing() const;
  inline void clear_bearing();
  static const int kBearingFieldNumber = 3;
  inline float bearing() const;
  inline void set_bearing(float value);
  
  // optional double odometer = 4;
  inline bool has_odometer() const;
  inline void clear_odometer();
  static const int kOdometerFieldNumber = 4;
  inline double odometer() const;
  inline void set_odometer(double value);
  
  // optional float speed = 5;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 5;
  inline float speed() const;
  inline void set_speed(float value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.Position)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  float latitude_;
  float longitude_;
  float bearing_;
  double odometer_;
  float speed_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Position* default_instance_;
};
// -------------------------------------------------------------------

class TripDescriptor : public ::google::protobuf::Message {
 public:
  TripDescriptor();
  virtual ~TripDescriptor();
  
  TripDescriptor(const TripDescriptor& from);
  
  inline TripDescriptor& operator=(const TripDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TripDescriptor& default_instance();
  
  void Swap(TripDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  TripDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TripDescriptor& from);
  void MergeFrom(const TripDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TripDescriptor_ScheduleRelationship ScheduleRelationship;
  static const ScheduleRelationship SCHEDULED = TripDescriptor_ScheduleRelationship_SCHEDULED;
  static const ScheduleRelationship ADDED = TripDescriptor_ScheduleRelationship_ADDED;
  static const ScheduleRelationship UNSCHEDULED = TripDescriptor_ScheduleRelationship_UNSCHEDULED;
  static const ScheduleRelationship CANCELED = TripDescriptor_ScheduleRelationship_CANCELED;
  static const ScheduleRelationship REPLACEMENT = TripDescriptor_ScheduleRelationship_REPLACEMENT;
  static inline bool ScheduleRelationship_IsValid(int value) {
    return TripDescriptor_ScheduleRelationship_IsValid(value);
  }
  static const ScheduleRelationship ScheduleRelationship_MIN =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MIN;
  static const ScheduleRelationship ScheduleRelationship_MAX =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_MAX;
  static const int ScheduleRelationship_ARRAYSIZE =
    TripDescriptor_ScheduleRelationship_ScheduleRelationship_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ScheduleRelationship_descriptor() {
    return TripDescriptor_ScheduleRelationship_descriptor();
  }
  static inline const ::std::string& ScheduleRelationship_Name(ScheduleRelationship value) {
    return TripDescriptor_ScheduleRelationship_Name(value);
  }
  static inline bool ScheduleRelationship_Parse(const ::std::string& name,
      ScheduleRelationship* value) {
    return TripDescriptor_ScheduleRelationship_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string trip_id = 1;
  inline bool has_trip_id() const;
  inline void clear_trip_id();
  static const int kTripIdFieldNumber = 1;
  inline const ::std::string& trip_id() const;
  inline void set_trip_id(const ::std::string& value);
  inline void set_trip_id(const char* value);
  inline void set_trip_id(const char* value, size_t size);
  inline ::std::string* mutable_trip_id();
  
  // optional string route_id = 5;
  inline bool has_route_id() const;
  inline void clear_route_id();
  static const int kRouteIdFieldNumber = 5;
  inline const ::std::string& route_id() const;
  inline void set_route_id(const ::std::string& value);
  inline void set_route_id(const char* value);
  inline void set_route_id(const char* value, size_t size);
  inline ::std::string* mutable_route_id();
  
  // optional string start_time = 2;
  inline bool has_start_time() const;
  inline void clear_start_time();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& start_time() const;
  inline void set_start_time(const ::std::string& value);
  inline void set_start_time(const char* value);
  inline void set_start_time(const char* value, size_t size);
  inline ::std::string* mutable_start_time();
  
  // optional string start_date = 3;
  inline bool has_start_date() const;
  inline void clear_start_date();
  static const int kStartDateFieldNumber = 3;
  inline const ::std::string& start_date() const;
  inline void set_start_date(const ::std::string& value);
  inline void set_start_date(const char* value);
  inline void set_start_date(const char* value, size_t size);
  inline ::std::string* mutable_start_date();
  
  // optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
  inline bool has_schedule_relationship() const;
  inline void clear_schedule_relationship();
  static const int kScheduleRelationshipFieldNumber = 4;
  inline ::transit_realtime::TripDescriptor_ScheduleRelationship schedule_relationship() const;
  inline void set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value);
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TripDescriptor)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* trip_id_;
  static const ::std::string _default_trip_id_;
  ::std::string* route_id_;
  static const ::std::string _default_route_id_;
  ::std::string* start_time_;
  static const ::std::string _default_start_time_;
  ::std::string* start_date_;
  static const ::std::string _default_start_date_;
  int schedule_relationship_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TripDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class VehicleDescriptor : public ::google::protobuf::Message {
 public:
  VehicleDescriptor();
  virtual ~VehicleDescriptor();
  
  VehicleDescriptor(const VehicleDescriptor& from);
  
  inline VehicleDescriptor& operator=(const VehicleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const VehicleDescriptor& default_instance();
  
  void Swap(VehicleDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  VehicleDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VehicleDescriptor& from);
  void MergeFrom(const VehicleDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  
  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  
  // optional string license_plate = 3;
  inline bool has_license_plate() const;
  inline void clear_license_plate();
  static const int kLicensePlateFieldNumber = 3;
  inline const ::std::string& license_plate() const;
  inline void set_license_plate(const ::std::string& value);
  inline void set_license_plate(const char* value);
  inline void set_license_plate(const char* value, size_t size);
  inline ::std::string* mutable_license_plate();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.VehicleDescriptor)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::std::string* label_;
  static const ::std::string _default_label_;
  ::std::string* license_plate_;
  static const ::std::string _default_license_plate_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static VehicleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class EntitySelector : public ::google::protobuf::Message {
 public:
  EntitySelector();
  virtual ~EntitySelector();
  
  EntitySelector(const EntitySelector& from);
  
  inline EntitySelector& operator=(const EntitySelector& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EntitySelector& default_instance();
  
  void Swap(EntitySelector* other);
  
  // implements Message ----------------------------------------------
  
  EntitySelector* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EntitySelector& from);
  void MergeFrom(const EntitySelector& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string agency_id = 1;
  inline bool has_agency_id() const;
  inline void clear_agency_id();
  static const int kAgencyIdFieldNumber = 1;
  inline const ::std::string& agency_id() const;
  inline void set_agency_id(const ::std::string& value);
  inline void set_agency_id(const char* value);
  inline void set_agency_id(const char* value, size_t size);
  inline ::std::string* mutable_agency_id();
  
  // optional string route_id = 2;
  inline bool has_route_id() const;
  inline void clear_route_id();
  static const int kRouteIdFieldNumber = 2;
  inline const ::std::string& route_id() const;
  inline void set_route_id(const ::std::string& value);
  inline void set_route_id(const char* value);
  inline void set_route_id(const char* value, size_t size);
  inline ::std::string* mutable_route_id();
  
  // optional int32 route_type = 3;
  inline bool has_route_type() const;
  inline void clear_route_type();
  static const int kRouteTypeFieldNumber = 3;
  inline ::google::protobuf::int32 route_type() const;
  inline void set_route_type(::google::protobuf::int32 value);
  
  // optional .transit_realtime.TripDescriptor trip = 4;
  inline bool has_trip() const;
  inline void clear_trip();
  static const int kTripFieldNumber = 4;
  inline const ::transit_realtime::TripDescriptor& trip() const;
  inline ::transit_realtime::TripDescriptor* mutable_trip();
  
  // optional string stop_id = 5;
  inline bool has_stop_id() const;
  inline void clear_stop_id();
  static const int kStopIdFieldNumber = 5;
  inline const ::std::string& stop_id() const;
  inline void set_stop_id(const ::std::string& value);
  inline void set_stop_id(const char* value);
  inline void set_stop_id(const char* value, size_t size);
  inline ::std::string* mutable_stop_id();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.EntitySelector)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* agency_id_;
  static const ::std::string _default_agency_id_;
  ::std::string* route_id_;
  static const ::std::string _default_route_id_;
  ::google::protobuf::int32 route_type_;
  ::transit_realtime::TripDescriptor* trip_;
  ::std::string* stop_id_;
  static const ::std::string _default_stop_id_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static EntitySelector* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString_Translation : public ::google::protobuf::Message {
 public:
  TranslatedString_Translation();
  virtual ~TranslatedString_Translation();
  
  TranslatedString_Translation(const TranslatedString_Translation& from);
  
  inline TranslatedString_Translation& operator=(const TranslatedString_Translation& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslatedString_Translation& default_instance();
  
  void Swap(TranslatedString_Translation* other);
  
  // implements Message ----------------------------------------------
  
  TranslatedString_Translation* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslatedString_Translation& from);
  void MergeFrom(const TranslatedString_Translation& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string text = 1;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 1;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  
  // optional string language = 2;
  inline bool has_language() const;
  inline void clear_language();
  static const int kLanguageFieldNumber = 2;
  inline const ::std::string& language() const;
  inline void set_language(const ::std::string& value);
  inline void set_language(const char* value);
  inline void set_language(const char* value, size_t size);
  inline ::std::string* mutable_language();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString.Translation)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* text_;
  static const ::std::string _default_text_;
  ::std::string* language_;
  static const ::std::string _default_language_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TranslatedString_Translation* default_instance_;
};
// -------------------------------------------------------------------

class TranslatedString : public ::google::protobuf::Message {
 public:
  TranslatedString();
  virtual ~TranslatedString();
  
  TranslatedString(const TranslatedString& from);
  
  inline TranslatedString& operator=(const TranslatedString& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TranslatedString& default_instance();
  
  void Swap(TranslatedString* other);
  
  // implements Message ----------------------------------------------
  
  TranslatedString* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TranslatedString& from);
  void MergeFrom(const TranslatedString& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef TranslatedString_Translation Translation;
  
  // accessors -------------------------------------------------------
  
  // repeated .transit_realtime.TranslatedString.Translation translation = 1;
  inline int translation_size() const;
  inline void clear_translation();
  static const int kTranslationFieldNumber = 1;
  inline const ::transit_realtime::TranslatedString_Translation& translation(int index) const;
  inline ::transit_realtime::TranslatedString_Translation* mutable_translation(int index);
  inline ::transit_realtime::TranslatedString_Translation* add_translation();
  inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
      translation() const;
  inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
      mutable_translation();
  
  // @@protoc_insertion_point(class_scope:transit_realtime.TranslatedString)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation > translation_;
  friend void  protobuf_AddDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_AssignDesc_gtfs_2drealtime_2eproto();
  friend void protobuf_ShutdownFile_gtfs_2drealtime_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TranslatedString* default_instance_;
};
// ===================================================================


// ===================================================================

// FeedMessage

// required .transit_realtime.FeedHeader header = 1;
inline bool FeedMessage::has_header() const {
  return _has_bit(0);
}
inline void FeedMessage::clear_header() {
  if (header_ != NULL) header_->::transit_realtime::FeedHeader::Clear();
  _clear_bit(0);
}
inline const ::transit_realtime::FeedHeader& FeedMessage::header() const {
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::transit_realtime::FeedHeader* FeedMessage::mutable_header() {
  _set_bit(0);
  if (header_ == NULL) header_ = new ::transit_realtime::FeedHeader;
  return header_;
}

// repeated .transit_realtime.FeedEntity entity = 2;
inline int FeedMessage::entity_size() const {
  return entity_.size();
}
inline void FeedMessage::clear_entity() {
  entity_.Clear();
}
inline const ::transit_realtime::FeedEntity& FeedMessage::entity(int index) const {
  return entity_.Get(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::mutable_entity(int index) {
  return entity_.Mutable(index);
}
inline ::transit_realtime::FeedEntity* FeedMessage::add_entity() {
  return entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >&
FeedMessage::entity() const {
  return entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::FeedEntity >*
FeedMessage::mutable_entity() {
  return &entity_;
}

// -------------------------------------------------------------------

// FeedHeader

// required string gtfs_realtime_version = 1;
inline bool FeedHeader::has_gtfs_realtime_version() const {
  return _has_bit(0);
}
inline void FeedHeader::clear_gtfs_realtime_version() {
  if (gtfs_realtime_version_ != &_default_gtfs_realtime_version_) {
    gtfs_realtime_version_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FeedHeader::gtfs_realtime_version() const {
  return *gtfs_realtime_version_;
}
inline void FeedHeader::set_gtfs_realtime_version(const ::std::string& value) {
  _set_bit(0);
  if (gtfs_realtime_version_ == &_default_gtfs_realtime_version_) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(value);
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value) {
  _set_bit(0);
  if (gtfs_realtime_version_ == &_default_gtfs_realtime_version_) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(value);
}
inline void FeedHeader::set_gtfs_realtime_version(const char* value, size_t size) {
  _set_bit(0);
  if (gtfs_realtime_version_ == &_default_gtfs_realtime_version_) {
    gtfs_realtime_version_ = new ::std::string;
  }
  gtfs_realtime_version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedHeader::mutable_gtfs_realtime_version() {
  _set_bit(0);
  if (gtfs_realtime_version_ == &_default_gtfs_realtime_version_) {
    gtfs_realtime_version_ = new ::std::string;
  }
  return gtfs_realtime_version_;
}

// optional .transit_realtime.FeedHeader.Incrementality incrementality = 2 [default = FULL_DATASET];
inline bool FeedHeader::has_incrementality() const {
  return _has_bit(1);
}
inline void FeedHeader::clear_incrementality() {
  incrementality_ = 0;
  _clear_bit(1);
}
inline ::transit_realtime::FeedHeader_Incrementality FeedHeader::incrementality() const {
  return static_cast< ::transit_realtime::FeedHeader_Incrementality >(incrementality_);
}
inline void FeedHeader::set_incrementality(::transit_realtime::FeedHeader_Incrementality value) {
  GOOGLE_DCHECK(::transit_realtime::FeedHeader_Incrementality_IsValid(value));
  _set_bit(1);
  incrementality_ = value;
}

// optional uint64 timestamp = 3;
inline bool FeedHeader::has_timestamp() const {
  return _has_bit(2);
}
inline void FeedHeader::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::uint64 FeedHeader::timestamp() const {
  return timestamp_;
}
inline void FeedHeader::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(2);
  timestamp_ = value;
}

// -------------------------------------------------------------------

// FeedEntity

// required string id = 1;
inline bool FeedEntity::has_id() const {
  return _has_bit(0);
}
inline void FeedEntity::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FeedEntity::id() const {
  return *id_;
}
inline void FeedEntity::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FeedEntity::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void FeedEntity::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeedEntity::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional bool is_deleted = 2 [default = false];
inline bool FeedEntity::has_is_deleted() const {
  return _has_bit(1);
}
inline void FeedEntity::clear_is_deleted() {
  is_deleted_ = false;
  _clear_bit(1);
}
inline bool FeedEntity::is_deleted() const {
  return is_deleted_;
}
inline void FeedEntity::set_is_deleted(bool value) {
  _set_bit(1);
  is_deleted_ = value;
}

// optional .transit_realtime.TripUpdate trip_update = 3;
inline bool FeedEntity::has_trip_update() const {
  return _has_bit(2);
}
inline void FeedEntity::clear_trip_update() {
  if (trip_update_ != NULL) trip_update_->::transit_realtime::TripUpdate::Clear();
  _clear_bit(2);
}
inline const ::transit_realtime::TripUpdate& FeedEntity::trip_update() const {
  return trip_update_ != NULL ? *trip_update_ : *default_instance_->trip_update_;
}
inline ::transit_realtime::TripUpdate* FeedEntity::mutable_trip_update() {
  _set_bit(2);
  if (trip_update_ == NULL) trip_update_ = new ::transit_realtime::TripUpdate;
  return trip_update_;
}

// optional .transit_realtime.VehiclePosition vehicle = 4;
inline bool FeedEntity::has_vehicle() const {
  return _has_bit(3);
}
inline void FeedEntity::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehiclePosition::Clear();
  _clear_bit(3);
}
inline const ::transit_realtime::VehiclePosition& FeedEntity::vehicle() const {
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehiclePosition* FeedEntity::mutable_vehicle() {
  _set_bit(3);
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehiclePosition;
  return vehicle_;
}

// optional .transit_realtime.Alert alert = 5;
inline bool FeedEntity::has_alert() const {
  return _has_bit(4);
}
inline void FeedEntity::clear_alert() {
  if (alert_ != NULL) alert_->::transit_realtime::Alert::Clear();
  _clear_bit(4);
}
inline const ::transit_realtime::Alert& FeedEntity::alert() const {
  return alert_ != NULL ? *alert_ : *default_instance_->alert_;
}
inline ::transit_realtime::Alert* FeedEntity::mutable_alert() {
  _set_bit(4);
  if (alert_ == NULL) alert_ = new ::transit_realtime::Alert;
  return alert_;
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeEvent

// optional int32 delay = 1;
inline bool TripUpdate_StopTimeEvent::has_delay() const {
  return _has_bit(0);
}
inline void TripUpdate_StopTimeEvent::clear_delay() {
  delay_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::delay() const {
  return delay_;
}
inline void TripUpdate_StopTimeEvent::set_delay(::google::protobuf::int32 value) {
  _set_bit(0);
  delay_ = value;
}

// optional int64 time = 2;
inline bool TripUpdate_StopTimeEvent::has_time() const {
  return _has_bit(1);
}
inline void TripUpdate_StopTimeEvent::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 TripUpdate_StopTimeEvent::time() const {
  return time_;
}
inline void TripUpdate_StopTimeEvent::set_time(::google::protobuf::int64 value) {
  _set_bit(1);
  time_ = value;
}

// optional int32 uncertainty = 3;
inline bool TripUpdate_StopTimeEvent::has_uncertainty() const {
  return _has_bit(2);
}
inline void TripUpdate_StopTimeEvent::clear_uncertainty() {
  uncertainty_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 TripUpdate_StopTimeEvent::uncertainty() const {
  return uncertainty_;
}
inline void TripUpdate_StopTimeEvent::set_uncertainty(::google::protobuf::int32 value) {
  _set_bit(2);
  uncertainty_ = value;
}

// -------------------------------------------------------------------

// TripUpdate_StopTimeUpdate

// optional uint32 stop_sequence = 1;
inline bool TripUpdate_StopTimeUpdate::has_stop_sequence() const {
  return _has_bit(0);
}
inline void TripUpdate_StopTimeUpdate::clear_stop_sequence() {
  stop_sequence_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 TripUpdate_StopTimeUpdate::stop_sequence() const {
  return stop_sequence_;
}
inline void TripUpdate_StopTimeUpdate::set_stop_sequence(::google::protobuf::uint32 value) {
  _set_bit(0);
  stop_sequence_ = value;
}

// optional string stop_id = 4;
inline bool TripUpdate_StopTimeUpdate::has_stop_id() const {
  return _has_bit(1);
}
inline void TripUpdate_StopTimeUpdate::clear_stop_id() {
  if (stop_id_ != &_default_stop_id_) {
    stop_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& TripUpdate_StopTimeUpdate::stop_id() const {
  return *stop_id_;
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const ::std::string& value) {
  _set_bit(1);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value) {
  _set_bit(1);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void TripUpdate_StopTimeUpdate::set_stop_id(const char* value, size_t size) {
  _set_bit(1);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripUpdate_StopTimeUpdate::mutable_stop_id() {
  _set_bit(1);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}

// optional .transit_realtime.TripUpdate.StopTimeEvent arrival = 2;
inline bool TripUpdate_StopTimeUpdate::has_arrival() const {
  return _has_bit(2);
}
inline void TripUpdate_StopTimeUpdate::clear_arrival() {
  if (arrival_ != NULL) arrival_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  _clear_bit(2);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::arrival() const {
  return arrival_ != NULL ? *arrival_ : *default_instance_->arrival_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_arrival() {
  _set_bit(2);
  if (arrival_ == NULL) arrival_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  return arrival_;
}

// optional .transit_realtime.TripUpdate.StopTimeEvent departure = 3;
inline bool TripUpdate_StopTimeUpdate::has_departure() const {
  return _has_bit(3);
}
inline void TripUpdate_StopTimeUpdate::clear_departure() {
  if (departure_ != NULL) departure_->::transit_realtime::TripUpdate_StopTimeEvent::Clear();
  _clear_bit(3);
}
inline const ::transit_realtime::TripUpdate_StopTimeEvent& TripUpdate_StopTimeUpdate::departure() const {
  return departure_ != NULL ? *departure_ : *default_instance_->departure_;
}
inline ::transit_realtime::TripUpdate_StopTimeEvent* TripUpdate_StopTimeUpdate::mutable_departure() {
  _set_bit(3);
  if (departure_ == NULL) departure_ = new ::transit_realtime::TripUpdate_StopTimeEvent;
  return departure_;
}

// optional .transit_realtime.TripUpdate.StopTimeUpdate.ScheduleRelationship schedule_relationship = 5 [default = SCHEDULED];
inline bool TripUpdate_StopTimeUpdate::has_schedule_relationship() const {
  return _has_bit(4);
}
inline void TripUpdate_StopTimeUpdate::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  _clear_bit(4);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship TripUpdate_StopTimeUpdate::schedule_relationship() const {
  return static_cast< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship >(schedule_relationship_);
}
inline void TripUpdate_StopTimeUpdate::set_schedule_relationship(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship value) {
  GOOGLE_DCHECK(::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_IsValid(value));
  _set_bit(4);
  schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// TripUpdate

// required .transit_realtime.TripDescriptor trip = 1;
inline bool TripUpdate::has_trip() const {
  return _has_bit(0);
}
inline void TripUpdate::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  _clear_bit(0);
}
inline const ::transit_realtime::TripDescriptor& TripUpdate::trip() const {
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* TripUpdate::mutable_trip() {
  _set_bit(0);
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}

// optional .transit_realtime.VehicleDescriptor vehicle = 3;
inline bool TripUpdate::has_vehicle() const {
  return _has_bit(1);
}
inline void TripUpdate::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  _clear_bit(1);
}
inline const ::transit_realtime::VehicleDescriptor& TripUpdate::vehicle() const {
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* TripUpdate::mutable_vehicle() {
  _set_bit(1);
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehicleDescriptor;
  return vehicle_;
}

// repeated .transit_realtime.TripUpdate.StopTimeUpdate stop_time_update = 2;
inline int TripUpdate::stop_time_update_size() const {
  return stop_time_update_.size();
}
inline void TripUpdate::clear_stop_time_update() {
  stop_time_update_.Clear();
}
inline const ::transit_realtime::TripUpdate_StopTimeUpdate& TripUpdate::stop_time_update(int index) const {
  return stop_time_update_.Get(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::mutable_stop_time_update(int index) {
  return stop_time_update_.Mutable(index);
}
inline ::transit_realtime::TripUpdate_StopTimeUpdate* TripUpdate::add_stop_time_update() {
  return stop_time_update_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >&
TripUpdate::stop_time_update() const {
  return stop_time_update_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TripUpdate_StopTimeUpdate >*
TripUpdate::mutable_stop_time_update() {
  return &stop_time_update_;
}

// -------------------------------------------------------------------

// VehiclePosition

// optional .transit_realtime.TripDescriptor trip = 1;
inline bool VehiclePosition::has_trip() const {
  return _has_bit(0);
}
inline void VehiclePosition::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  _clear_bit(0);
}
inline const ::transit_realtime::TripDescriptor& VehiclePosition::trip() const {
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* VehiclePosition::mutable_trip() {
  _set_bit(0);
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}

// optional .transit_realtime.VehicleDescriptor vehicle = 8;
inline bool VehiclePosition::has_vehicle() const {
  return _has_bit(1);
}
inline void VehiclePosition::clear_vehicle() {
  if (vehicle_ != NULL) vehicle_->::transit_realtime::VehicleDescriptor::Clear();
  _clear_bit(1);
}
inline const ::transit_realtime::VehicleDescriptor& VehiclePosition::vehicle() const {
  return vehicle_ != NULL ? *vehicle_ : *default_instance_->vehicle_;
}
inline ::transit_realtime::VehicleDescriptor* VehiclePosition::mutable_vehicle() {
  _set_bit(1);
  if (vehicle_ == NULL) vehicle_ = new ::transit_realtime::VehicleDescriptor;
  return vehicle_;
}

// optional .transit_realtime.Position position = 2;
inline bool VehiclePosition::has_position() const {
  return _has_bit(2);
}
inline void VehiclePosition::clear_position() {
  if (position_ != NULL) position_->::transit_realtime::Position::Clear();
  _clear_bit(2);
}
inline const ::transit_realtime::Position& VehiclePosition::position() const {
  return position_ != NULL ? *position_ : *default_instance_->position_;
}
inline ::transit_realtime::Position* VehiclePosition::mutable_position() {
  _set_bit(2);
  if (position_ == NULL) position_ = new ::transit_realtime::Position;
  return position_;
}

// optional uint32 current_stop_sequence = 3;
inline bool VehiclePosition::has_current_stop_sequence() const {
  return _has_bit(3);
}
inline void VehiclePosition::clear_current_stop_sequence() {
  current_stop_sequence_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 VehiclePosition::current_stop_sequence() const {
  return current_stop_sequence_;
}
inline void VehiclePosition::set_current_stop_sequence(::google::protobuf::uint32 value) {
  _set_bit(3);
  current_stop_sequence_ = value;
}

// optional string stop_id = 7;
inline bool VehiclePosition::has_stop_id() const {
  return _has_bit(4);
}
inline void VehiclePosition::clear_stop_id() {
  if (stop_id_ != &_default_stop_id_) {
    stop_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& VehiclePosition::stop_id() const {
  return *stop_id_;
}
inline void VehiclePosition::set_stop_id(const ::std::string& value) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void VehiclePosition::set_stop_id(const char* value) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void VehiclePosition::set_stop_id(const char* value, size_t size) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehiclePosition::mutable_stop_id() {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}

// optional .transit_realtime.VehiclePosition.VehicleStopStatus current_status = 4 [default = IN_TRANSIT_TO];
inline bool VehiclePosition::has_current_status() const {
  return _has_bit(5);
}
inline void VehiclePosition::clear_current_status() {
  current_status_ = 2;
  _clear_bit(5);
}
inline ::transit_realtime::VehiclePosition_VehicleStopStatus VehiclePosition::current_status() const {
  return static_cast< ::transit_realtime::VehiclePosition_VehicleStopStatus >(current_status_);
}
inline void VehiclePosition::set_current_status(::transit_realtime::VehiclePosition_VehicleStopStatus value) {
  GOOGLE_DCHECK(::transit_realtime::VehiclePosition_VehicleStopStatus_IsValid(value));
  _set_bit(5);
  current_status_ = value;
}

// optional uint64 timestamp = 5;
inline bool VehiclePosition::has_timestamp() const {
  return _has_bit(6);
}
inline void VehiclePosition::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  _clear_bit(6);
}
inline ::google::protobuf::uint64 VehiclePosition::timestamp() const {
  return timestamp_;
}
inline void VehiclePosition::set_timestamp(::google::protobuf::uint64 value) {
  _set_bit(6);
  timestamp_ = value;
}

// optional .transit_realtime.VehiclePosition.CongestionLevel congestion_level = 6;
inline bool VehiclePosition::has_congestion_level() const {
  return _has_bit(7);
}
inline void VehiclePosition::clear_congestion_level() {
  congestion_level_ = 0;
  _clear_bit(7);
}
inline ::transit_realtime::VehiclePosition_CongestionLevel VehiclePosition::congestion_level() const {
  return static_cast< ::transit_realtime::VehiclePosition_CongestionLevel >(congestion_level_);
}
inline void VehiclePosition::set_congestion_level(::transit_realtime::VehiclePosition_CongestionLevel value) {
  GOOGLE_DCHECK(::transit_realtime::VehiclePosition_CongestionLevel_IsValid(value));
  _set_bit(7);
  congestion_level_ = value;
}

// -------------------------------------------------------------------

// Alert

// repeated .transit_realtime.TimeRange active_period = 1;
inline int Alert::active_period_size() const {
  return active_period_.size();
}
inline void Alert::clear_active_period() {
  active_period_.Clear();
}
inline const ::transit_realtime::TimeRange& Alert::active_period(int index) const {
  return active_period_.Get(index);
}
inline ::transit_realtime::TimeRange* Alert::mutable_active_period(int index) {
  return active_period_.Mutable(index);
}
inline ::transit_realtime::TimeRange* Alert::add_active_period() {
  return active_period_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >&
Alert::active_period() const {
  return active_period_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TimeRange >*
Alert::mutable_active_period() {
  return &active_period_;
}

// repeated .transit_realtime.EntitySelector informed_entity = 5;
inline int Alert::informed_entity_size() const {
  return informed_entity_.size();
}
inline void Alert::clear_informed_entity() {
  informed_entity_.Clear();
}
inline const ::transit_realtime::EntitySelector& Alert::informed_entity(int index) const {
  return informed_entity_.Get(index);
}
inline ::transit_realtime::EntitySelector* Alert::mutable_informed_entity(int index) {
  return informed_entity_.Mutable(index);
}
inline ::transit_realtime::EntitySelector* Alert::add_informed_entity() {
  return informed_entity_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >&
Alert::informed_entity() const {
  return informed_entity_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::EntitySelector >*
Alert::mutable_informed_entity() {
  return &informed_entity_;
}

// optional .transit_realtime.Alert.Cause cause = 6 [default = UNKNOWN_CAUSE];
inline bool Alert::has_cause() const {
  return _has_bit(2);
}
inline void Alert::clear_cause() {
  cause_ = 1;
  _clear_bit(2);
}
inline ::transit_realtime::Alert_Cause Alert::cause() const {
  return static_cast< ::transit_realtime::Alert_Cause >(cause_);
}
inline void Alert::set_cause(::transit_realtime::Alert_Cause value) {
  GOOGLE_DCHECK(::transit_realtime::Alert_Cause_IsValid(value));
  _set_bit(2);
  cause_ = value;
}

// optional .transit_realtime.Alert.Effect effect = 7 [default = UNKNOWN_EFFECT];
inline bool Alert::has_effect() const {
  return _has_bit(3);
}
inline void Alert::clear_effect() {
  effect_ = 8;
  _clear_bit(3);
}
inline ::transit_realtime::Alert_Effect Alert::effect() const {
  return static_cast< ::transit_realtime::Alert_Effect >(effect_);
}
inline void Alert::set_effect(::transit_realtime::Alert_Effect value) {
  GOOGLE_DCHECK(::transit_realtime::Alert_Effect_IsValid(value));
  _set_bit(3);
  effect_ = value;
}

// optional .transit_realtime.TranslatedString url = 8;
inline bool Alert::has_url() const {
  return _has_bit(4);
}
inline void Alert::clear_url() {
  if (url_ != NULL) url_->::transit_realtime::TranslatedString::Clear();
  _clear_bit(4);
}
inline const ::transit_realtime::TranslatedString& Alert::url() const {
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_url() {
  _set_bit(4);
  if (url_ == NULL) url_ = new ::transit_realtime::TranslatedString;
  return url_;
}

// optional .transit_realtime.TranslatedString header_text = 10;
inline bool Alert::has_header_text() const {
  return _has_bit(5);
}
inline void Alert::clear_header_text() {
  if (header_text_ != NULL) header_text_->::transit_realtime::TranslatedString::Clear();
  _clear_bit(5);
}
inline const ::transit_realtime::TranslatedString& Alert::header_text() const {
  return header_text_ != NULL ? *header_text_ : *default_instance_->header_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_header_text() {
  _set_bit(5);
  if (header_text_ == NULL) header_text_ = new ::transit_realtime::TranslatedString;
  return header_text_;
}

// optional .transit_realtime.TranslatedString description_text = 11;
inline bool Alert::has_description_text() const {
  return _has_bit(6);
}
inline void Alert::clear_description_text() {
  if (description_text_ != NULL) description_text_->::transit_realtime::TranslatedString::Clear();
  _clear_bit(6);
}
inline const ::transit_realtime::TranslatedString& Alert::description_text() const {
  return description_text_ != NULL ? *description_text_ : *default_instance_->description_text_;
}
inline ::transit_realtime::TranslatedString* Alert::mutable_description_text() {
  _set_bit(6);
  if (description_text_ == NULL) description_text_ = new ::transit_realtime::TranslatedString;
  return description_text_;
}

// -------------------------------------------------------------------

// TimeRange

// optional uint64 start = 1;
inline bool TimeRange::has_start() const {
  return _has_bit(0);
}
inline void TimeRange::clear_start() {
  start_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 TimeRange::start() const {
  return start_;
}
inline void TimeRange::set_start(::google::protobuf::uint64 value) {
  _set_bit(0);
  start_ = value;
}

// optional uint64 end = 2;
inline bool TimeRange::has_end() const {
  return _has_bit(1);
}
inline void TimeRange::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 TimeRange::end() const {
  return end_;
}
inline void TimeRange::set_end(::google::protobuf::uint64 value) {
  _set_bit(1);
  end_ = value;
}

// -------------------------------------------------------------------

// Position

// required float latitude = 1;
inline bool Position::has_latitude() const {
  return _has_bit(0);
}
inline void Position::clear_latitude() {
  latitude_ = 0;
  _clear_bit(0);
}
inline float Position::latitude() const {
  return latitude_;
}
inline void Position::set_latitude(float value) {
  _set_bit(0);
  latitude_ = value;
}

// required float longitude = 2;
inline bool Position::has_longitude() const {
  return _has_bit(1);
}
inline void Position::clear_longitude() {
  longitude_ = 0;
  _clear_bit(1);
}
inline float Position::longitude() const {
  return longitude_;
}
inline void Position::set_longitude(float value) {
  _set_bit(1);
  longitude_ = value;
}

// optional float bearing = 3;
inline bool Position::has_bearing() const {
  return _has_bit(2);
}
inline void Position::clear_bearing() {
  bearing_ = 0;
  _clear_bit(2);
}
inline float Position::bearing() const {
  return bearing_;
}
inline void Position::set_bearing(float value) {
  _set_bit(2);
  bearing_ = value;
}

// optional double odometer = 4;
inline bool Position::has_odometer() const {
  return _has_bit(3);
}
inline void Position::clear_odometer() {
  odometer_ = 0;
  _clear_bit(3);
}
inline double Position::odometer() const {
  return odometer_;
}
inline void Position::set_odometer(double value) {
  _set_bit(3);
  odometer_ = value;
}

// optional float speed = 5;
inline bool Position::has_speed() const {
  return _has_bit(4);
}
inline void Position::clear_speed() {
  speed_ = 0;
  _clear_bit(4);
}
inline float Position::speed() const {
  return speed_;
}
inline void Position::set_speed(float value) {
  _set_bit(4);
  speed_ = value;
}

// -------------------------------------------------------------------

// TripDescriptor

// optional string trip_id = 1;
inline bool TripDescriptor::has_trip_id() const {
  return _has_bit(0);
}
inline void TripDescriptor::clear_trip_id() {
  if (trip_id_ != &_default_trip_id_) {
    trip_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TripDescriptor::trip_id() const {
  return *trip_id_;
}
inline void TripDescriptor::set_trip_id(const ::std::string& value) {
  _set_bit(0);
  if (trip_id_ == &_default_trip_id_) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(value);
}
inline void TripDescriptor::set_trip_id(const char* value) {
  _set_bit(0);
  if (trip_id_ == &_default_trip_id_) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(value);
}
inline void TripDescriptor::set_trip_id(const char* value, size_t size) {
  _set_bit(0);
  if (trip_id_ == &_default_trip_id_) {
    trip_id_ = new ::std::string;
  }
  trip_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_trip_id() {
  _set_bit(0);
  if (trip_id_ == &_default_trip_id_) {
    trip_id_ = new ::std::string;
  }
  return trip_id_;
}

// optional string route_id = 5;
inline bool TripDescriptor::has_route_id() const {
  return _has_bit(1);
}
inline void TripDescriptor::clear_route_id() {
  if (route_id_ != &_default_route_id_) {
    route_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& TripDescriptor::route_id() const {
  return *route_id_;
}
inline void TripDescriptor::set_route_id(const ::std::string& value) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void TripDescriptor::set_route_id(const char* value) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void TripDescriptor::set_route_id(const char* value, size_t size) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_route_id() {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  return route_id_;
}

// optional string start_time = 2;
inline bool TripDescriptor::has_start_time() const {
  return _has_bit(2);
}
inline void TripDescriptor::clear_start_time() {
  if (start_time_ != &_default_start_time_) {
    start_time_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& TripDescriptor::start_time() const {
  return *start_time_;
}
inline void TripDescriptor::set_start_time(const ::std::string& value) {
  _set_bit(2);
  if (start_time_ == &_default_start_time_) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TripDescriptor::set_start_time(const char* value) {
  _set_bit(2);
  if (start_time_ == &_default_start_time_) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(value);
}
inline void TripDescriptor::set_start_time(const char* value, size_t size) {
  _set_bit(2);
  if (start_time_ == &_default_start_time_) {
    start_time_ = new ::std::string;
  }
  start_time_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_start_time() {
  _set_bit(2);
  if (start_time_ == &_default_start_time_) {
    start_time_ = new ::std::string;
  }
  return start_time_;
}

// optional string start_date = 3;
inline bool TripDescriptor::has_start_date() const {
  return _has_bit(3);
}
inline void TripDescriptor::clear_start_date() {
  if (start_date_ != &_default_start_date_) {
    start_date_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& TripDescriptor::start_date() const {
  return *start_date_;
}
inline void TripDescriptor::set_start_date(const ::std::string& value) {
  _set_bit(3);
  if (start_date_ == &_default_start_date_) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void TripDescriptor::set_start_date(const char* value) {
  _set_bit(3);
  if (start_date_ == &_default_start_date_) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(value);
}
inline void TripDescriptor::set_start_date(const char* value, size_t size) {
  _set_bit(3);
  if (start_date_ == &_default_start_date_) {
    start_date_ = new ::std::string;
  }
  start_date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TripDescriptor::mutable_start_date() {
  _set_bit(3);
  if (start_date_ == &_default_start_date_) {
    start_date_ = new ::std::string;
  }
  return start_date_;
}

// optional .transit_realtime.TripDescriptor.ScheduleRelationship schedule_relationship = 4;
inline bool TripDescriptor::has_schedule_relationship() const {
  return _has_bit(4);
}
inline void TripDescriptor::clear_schedule_relationship() {
  schedule_relationship_ = 0;
  _clear_bit(4);
}
inline ::transit_realtime::TripDescriptor_ScheduleRelationship TripDescriptor::schedule_relationship() const {
  return static_cast< ::transit_realtime::TripDescriptor_ScheduleRelationship >(schedule_relationship_);
}
inline void TripDescriptor::set_schedule_relationship(::transit_realtime::TripDescriptor_ScheduleRelationship value) {
  GOOGLE_DCHECK(::transit_realtime::TripDescriptor_ScheduleRelationship_IsValid(value));
  _set_bit(4);
  schedule_relationship_ = value;
}

// -------------------------------------------------------------------

// VehicleDescriptor

// optional string id = 1;
inline bool VehicleDescriptor::has_id() const {
  return _has_bit(0);
}
inline void VehicleDescriptor::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& VehicleDescriptor::id() const {
  return *id_;
}
inline void VehicleDescriptor::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void VehicleDescriptor::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void VehicleDescriptor::set_id(const char* value, size_t size) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional string label = 2;
inline bool VehicleDescriptor::has_label() const {
  return _has_bit(1);
}
inline void VehicleDescriptor::clear_label() {
  if (label_ != &_default_label_) {
    label_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& VehicleDescriptor::label() const {
  return *label_;
}
inline void VehicleDescriptor::set_label(const ::std::string& value) {
  _set_bit(1);
  if (label_ == &_default_label_) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VehicleDescriptor::set_label(const char* value) {
  _set_bit(1);
  if (label_ == &_default_label_) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void VehicleDescriptor::set_label(const char* value, size_t size) {
  _set_bit(1);
  if (label_ == &_default_label_) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_label() {
  _set_bit(1);
  if (label_ == &_default_label_) {
    label_ = new ::std::string;
  }
  return label_;
}

// optional string license_plate = 3;
inline bool VehicleDescriptor::has_license_plate() const {
  return _has_bit(2);
}
inline void VehicleDescriptor::clear_license_plate() {
  if (license_plate_ != &_default_license_plate_) {
    license_plate_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& VehicleDescriptor::license_plate() const {
  return *license_plate_;
}
inline void VehicleDescriptor::set_license_plate(const ::std::string& value) {
  _set_bit(2);
  if (license_plate_ == &_default_license_plate_) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(value);
}
inline void VehicleDescriptor::set_license_plate(const char* value) {
  _set_bit(2);
  if (license_plate_ == &_default_license_plate_) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(value);
}
inline void VehicleDescriptor::set_license_plate(const char* value, size_t size) {
  _set_bit(2);
  if (license_plate_ == &_default_license_plate_) {
    license_plate_ = new ::std::string;
  }
  license_plate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* VehicleDescriptor::mutable_license_plate() {
  _set_bit(2);
  if (license_plate_ == &_default_license_plate_) {
    license_plate_ = new ::std::string;
  }
  return license_plate_;
}

// -------------------------------------------------------------------

// EntitySelector

// optional string agency_id = 1;
inline bool EntitySelector::has_agency_id() const {
  return _has_bit(0);
}
inline void EntitySelector::clear_agency_id() {
  if (agency_id_ != &_default_agency_id_) {
    agency_id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& EntitySelector::agency_id() const {
  return *agency_id_;
}
inline void EntitySelector::set_agency_id(const ::std::string& value) {
  _set_bit(0);
  if (agency_id_ == &_default_agency_id_) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(value);
}
inline void EntitySelector::set_agency_id(const char* value) {
  _set_bit(0);
  if (agency_id_ == &_default_agency_id_) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(value);
}
inline void EntitySelector::set_agency_id(const char* value, size_t size) {
  _set_bit(0);
  if (agency_id_ == &_default_agency_id_) {
    agency_id_ = new ::std::string;
  }
  agency_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_agency_id() {
  _set_bit(0);
  if (agency_id_ == &_default_agency_id_) {
    agency_id_ = new ::std::string;
  }
  return agency_id_;
}

// optional string route_id = 2;
inline bool EntitySelector::has_route_id() const {
  return _has_bit(1);
}
inline void EntitySelector::clear_route_id() {
  if (route_id_ != &_default_route_id_) {
    route_id_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& EntitySelector::route_id() const {
  return *route_id_;
}
inline void EntitySelector::set_route_id(const ::std::string& value) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void EntitySelector::set_route_id(const char* value) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(value);
}
inline void EntitySelector::set_route_id(const char* value, size_t size) {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  route_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_route_id() {
  _set_bit(1);
  if (route_id_ == &_default_route_id_) {
    route_id_ = new ::std::string;
  }
  return route_id_;
}

// optional int32 route_type = 3;
inline bool EntitySelector::has_route_type() const {
  return _has_bit(2);
}
inline void EntitySelector::clear_route_type() {
  route_type_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 EntitySelector::route_type() const {
  return route_type_;
}
inline void EntitySelector::set_route_type(::google::protobuf::int32 value) {
  _set_bit(2);
  route_type_ = value;
}

// optional .transit_realtime.TripDescriptor trip = 4;
inline bool EntitySelector::has_trip() const {
  return _has_bit(3);
}
inline void EntitySelector::clear_trip() {
  if (trip_ != NULL) trip_->::transit_realtime::TripDescriptor::Clear();
  _clear_bit(3);
}
inline const ::transit_realtime::TripDescriptor& EntitySelector::trip() const {
  return trip_ != NULL ? *trip_ : *default_instance_->trip_;
}
inline ::transit_realtime::TripDescriptor* EntitySelector::mutable_trip() {
  _set_bit(3);
  if (trip_ == NULL) trip_ = new ::transit_realtime::TripDescriptor;
  return trip_;
}

// optional string stop_id = 5;
inline bool EntitySelector::has_stop_id() const {
  return _has_bit(4);
}
inline void EntitySelector::clear_stop_id() {
  if (stop_id_ != &_default_stop_id_) {
    stop_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& EntitySelector::stop_id() const {
  return *stop_id_;
}
inline void EntitySelector::set_stop_id(const ::std::string& value) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void EntitySelector::set_stop_id(const char* value) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(value);
}
inline void EntitySelector::set_stop_id(const char* value, size_t size) {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  stop_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EntitySelector::mutable_stop_id() {
  _set_bit(4);
  if (stop_id_ == &_default_stop_id_) {
    stop_id_ = new ::std::string;
  }
  return stop_id_;
}

// -------------------------------------------------------------------

// TranslatedString_Translation

// required string text = 1;
inline bool TranslatedString_Translation::has_text() const {
  return _has_bit(0);
}
inline void TranslatedString_Translation::clear_text() {
  if (text_ != &_default_text_) {
    text_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& TranslatedString_Translation::text() const {
  return *text_;
}
inline void TranslatedString_Translation::set_text(const ::std::string& value) {
  _set_bit(0);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TranslatedString_Translation::set_text(const char* value) {
  _set_bit(0);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TranslatedString_Translation::set_text(const char* value, size_t size) {
  _set_bit(0);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslatedString_Translation::mutable_text() {
  _set_bit(0);
  if (text_ == &_default_text_) {
    text_ = new ::std::string;
  }
  return text_;
}

// optional string language = 2;
inline bool TranslatedString_Translation::has_language() const {
  return _has_bit(1);
}
inline void TranslatedString_Translation::clear_language() {
  if (language_ != &_default_language_) {
    language_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& TranslatedString_Translation::language() const {
  return *language_;
}
inline void TranslatedString_Translation::set_language(const ::std::string& value) {
  _set_bit(1);
  if (language_ == &_default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void TranslatedString_Translation::set_language(const char* value) {
  _set_bit(1);
  if (language_ == &_default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(value);
}
inline void TranslatedString_Translation::set_language(const char* value, size_t size) {
  _set_bit(1);
  if (language_ == &_default_language_) {
    language_ = new ::std::string;
  }
  language_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TranslatedString_Translation::mutable_language() {
  _set_bit(1);
  if (language_ == &_default_language_) {
    language_ = new ::std::string;
  }
  return language_;
}

// -------------------------------------------------------------------

// TranslatedString

// repeated .transit_realtime.TranslatedString.Translation translation = 1;
inline int TranslatedString::translation_size() const {
  return translation_.size();
}
inline void TranslatedString::clear_translation() {
  translation_.Clear();
}
inline const ::transit_realtime::TranslatedString_Translation& TranslatedString::translation(int index) const {
  return translation_.Get(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::mutable_translation(int index) {
  return translation_.Mutable(index);
}
inline ::transit_realtime::TranslatedString_Translation* TranslatedString::add_translation() {
  return translation_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >&
TranslatedString::translation() const {
  return translation_;
}
inline ::google::protobuf::RepeatedPtrField< ::transit_realtime::TranslatedString_Translation >*
TranslatedString::mutable_translation() {
  return &translation_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace transit_realtime

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::FeedHeader_Incrementality>() {
  return ::transit_realtime::FeedHeader_Incrementality_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship>() {
  return ::transit_realtime::TripUpdate_StopTimeUpdate_ScheduleRelationship_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_VehicleStopStatus>() {
  return ::transit_realtime::VehiclePosition_VehicleStopStatus_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::VehiclePosition_CongestionLevel>() {
  return ::transit_realtime::VehiclePosition_CongestionLevel_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Cause>() {
  return ::transit_realtime::Alert_Cause_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::Alert_Effect>() {
  return ::transit_realtime::Alert_Effect_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::transit_realtime::TripDescriptor_ScheduleRelationship>() {
  return ::transit_realtime::TripDescriptor_ScheduleRelationship_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_gtfs_2drealtime_2eproto__INCLUDED
