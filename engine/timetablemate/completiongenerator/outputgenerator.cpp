/*
*   Copyright 2012 Friedrich PÃ¼lz <fpuelz@gmx.de>
*
*   This program is free software; you can redistribute it and/or modify
*   it under the terms of the GNU Library General Public License as
*   published by the Free Software Foundation; either version 2 or
*   (at your option) any later version.
*
*   This program is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details
*
*   You should have received a copy of the GNU Library General Public
*   License along with this program; if not, write to the
*   Free Software Foundation, Inc.,
*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
*/

// Header
#include "outputgenerator.h"

// Own includes
#include "documentationparser.h"

// Qt includes
#include <QDateTime>

const char *OutputGenerator::OUTPUT_FILE_GENERATOR_COMMENT
        = "This file was generated by CompletionGenerator";

bool OutputGenerator::writeCompletionSource( const ClassInformationList &completionClasses,
                                             const QString &outputDirectory,
                                             const QString &completionClassName )
{
    const QString baseFileName = outputDirectory + '/' + completionClassName.toLower();
    const QString headerFilePath = baseFileName + ".h";
    const QString sourceFilePath = baseFileName + ".cpp";
    const bool success = writeSourceHeaderOutput( headerFilePath, completionClassName );
    return writeSourceOutput( sourceFilePath, headerFilePath, completionClasses,
                              completionClassName ) && success;
}

bool OutputGenerator::writeDocumentation( const ClassInformationList &documentationClasses,
                                          const Comments &globalComments,
                                          const EnumCommentList &enumComments,
                                          const QString &outputDirectory,
                                          const QString &htmlHomeFileName, const QString &cssFileName )
{
    const QString cssFilePath = outputDirectory + '/' + cssFileName;
    const bool success = writeCssOutput( cssFilePath );
    return writeHtmlOutput( outputDirectory, htmlHomeFileName, cssFileName,
                            documentationClasses, globalComments, enumComments ) && success;
}

bool OutputGenerator::openGenerationFile( const QString &fileName, QFile *file )
{
    QString canonicalFilePath = QFileInfo(fileName).canonicalFilePath();
    if ( canonicalFilePath.isEmpty() ) {
        canonicalFilePath = fileName;
    }
    file->setFileName( canonicalFilePath );
    if( !file->open(QIODevice::WriteOnly | QIODevice::Truncate) ) {
        qDebug() << "Could not open output file" << canonicalFilePath;
        return false;
    }

    m_generatedFiles << canonicalFilePath;

    // Print out output file path
    // (.toUtf8().constData() to have qDebug() not print the string in quotation marks)
    qDebug() << "Generating" << canonicalFilePath.toUtf8().constData();
    return true;
}

bool OutputGenerator::writeSourceHeaderOutput( const QString &headerFilePath,
                                               const QString &className )
{
    QFile output;
    if ( !openGenerationFile(headerFilePath, &output) ) {
        return false;
    }

    const QString timeString = QDateTime::currentDateTime().toString();
    output.write( QString(
        "// %1\n"
        "// Time: %2\n"
        "\n"
        "#ifndef %3_HEADER\n"
        "#define %3_HEADER\n"
        "\n"
        "#include <QHash>\n"
        "#include \"javascriptcompletionmodel.h\"\n"
        "\n"
        "/**\n"
        " * @brief This class provides completion information.\n"
        " **/\n"
        "class %4 {\n"
        "public:\n"
        "    /**\n"
        "     * @brief Adds automatically generated completions.\n"
        "     *\n"
        "     * @param completions A pointer to a QHash object that gets filled with the\n"
        "     *   available completion items per class. The keys are used for the class names\n"
        "     *   and the values are again QHash objects. The inner QHash uses \"completion\n"
        "     *   strings\" as keys (eg. \"call:functionName()\") and CompletionItem objects\n"
        "     *   as values.\n"
        "     **/\n"
        "    static void addCompletions( QHash< QString, QHash<QString, CompletionItem> > *completions );\n"
        "\n"
        "    /**\n"
        "     * @brief Adds names of available methods per script object.\n"
        "     *\n"
        "     * @param methods A pointer to a QHash object that gets filled with the\n"
        "     *   available methods per class, ie. the keys are used for the class names\n"
        "     *   and the values are lists of methods of these classes.\n"
        "     **/\n"
        "    static void addAvailableMethods( QHash< QString, QStringList > *methods );\n"
        "};\n"
        "\n"
        "#endif // Multiple inclusion guard\n")
        .arg(OUTPUT_FILE_GENERATOR_COMMENT).arg(timeString)
        .arg(className.toUpper()).arg(className).toUtf8() );
    output.close();
    return true;
}

bool OutputGenerator::writeSourceOutput( const QString &sourceFilePath,
        const QString &headerFileName, const ClassInformationList &completionClasses,
        const QString &className )
{
    QFile output;
    if ( !openGenerationFile(sourceFilePath, &output) ) {
        return false;
    }

    // Write creation comment, includes and implement JavaScriptCompletionGeneric::addCompletions()
    const QString timeString = QDateTime::currentDateTime().toString();
    output.write( QString(
        "// %1\n"
        "// Time: %2\n"
        "\n"
        "#include \"%3\"\n"
        "#include <QStringList>\n"
        "\n"
        "void %4::addCompletions( QHash< QString, QHash<QString, CompletionItem> > *completions ) {\n")
        .arg(OUTPUT_FILE_GENERATOR_COMMENT).arg(timeString)
        .arg(headerFileName).arg(className).toUtf8() );
    foreach( const ClassInformation &classInformation, completionClasses ) {
        writeAddCompletionsImplementation( &output, classInformation );
    }
    output.write( "}\n\n" );

    // Implement JavaScriptCompletionGeneric::addAvailableMethods()
    output.write( QString(
        "void %1::addAvailableMethods( QHash< QString, QStringList > *methods ) {\n")
        .arg(className).toUtf8() );
    foreach( const ClassInformation &classInformation, completionClasses ) {
        writeAddAvailableMethodsImplementation( &output, classInformation );
    }
    output.write( "}\n" );
    output.close();
    return true;
}

bool OutputGenerator::writeCssOutput( const QString &cssFilePath )
{
    QFile output;
    if ( !openGenerationFile(cssFilePath, &output) ) {
        return false;
    }

    const QString timeString = QDateTime::currentDateTime().toString();
    output.write( QString(
        "/* %1\n"
        "   Time: %2 */\n"
        "\n"
        "body {\n"
        "    margin: 0px; /* no border at the sides */\n"
        "    font-family: sans-serif;\n"
        "}\n"
        "a {\n"
        "    color: rgb(0, 67, 138); /* Oxygen skyblue5 */\n"
        "}\n"
        ".table_of_contents a, .table_of_contents > ul > li {\n"
        "    text-decoration: none;\n"
        "    font-size: 1.05em;\n"
        "}\n"
        ".table_of_contents li {\n"
        "    margin-top: 5px;\n"
        "}\n"
        ".toc_sub_entry_list li {\n"
        "    margin-top: 2px;\n"
        "}\n"
        ".toc_sub_entry_list {\n"
        "    font-size: 0.95em;\n"
        "    \n"
        "}\n"
        ".title {\n"
        "    font-weight: bold;\n"
        "}\n"
        ".title_todo, .title_warning, .title_deprecated, .title_bug {\n"
        "    color: rgb(156,  15, 15); /* Oxygen brick red6 */\n"
        "}\n"
        ".overview, .class_details {\n"
        "    margin-bottom: 30px;\n"
        "}\n"
        ".overview, .class_details, .table_of_contents, .method, .enumerations {\n"
//         "    background-image: linear-gradient(bottom, rgb(187, 187, 187) 85%, rgb(238, 238, 236) 15%);\n"
        "    background-image: linear-gradient(left , rgb(238,238,238) 0%, rgb(255,255,255) 100%);\n"
        "    background-image: -webkit-linear-gradient(left , rgb(238,238,238) 0%, rgb(255,255,255) 100%);\n"
        "    background-image: -moz-linear-gradient(left , rgb(238,238,238) 0%, rgb(255,255,255) 100%);\n"
        "}\n"
        ".overview, .class_details, .table_of_contents {\n"
        "    padding: 0 11px 11px;\n"
        "    border-top: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    border-bottom: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    background-color: rgb(238, 238, 236); /* Oxygen gray1 */\n"
//         "    border-radius: 10px;\n"
        "}\n"
        "h2, h3 {\n"
        "    margin: 11px -11px; /* the (-)11 equals padding of '.overview, .class_details, ...' */\n"
        "    padding: 5px 22px;\n"
        "}\n"
        "h2 {\n"
        "    border-top: 1px solid rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "    border-bottom: 1px solid rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "    background-color: rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    background-image: linear-gradient(left , rgb(85, 85, 85) 0%, rgb(187, 187, 187) 100%);\n"
        "    background-image: -webkit-linear-gradient(left , rgb(85, 85, 85) 0%, rgb(187, 187, 187) 100%);\n"
        "    background-image: -moz-linear-gradient(left , rgb(85, 85, 85) 0%, rgb(187, 187, 187) 100%);\n"
        "    color: rgb(238, 238, 236); /* Oxygen gray1 */\n"
        "}\n"
        "h3 {\n"
        "    color: rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "    border-top: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    border-bottom: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    background-color: rgb(221, 221, 221); /* Oxygen gray2 */\n"
        "    background-image: linear-gradient(left , rgb(221, 221, 221) 0%, rgb(238, 238, 236) 100%);\n"
        "    background-image: -webkit-linear-gradient(left , rgb(221, 221, 221) 0%, rgb(238, 238, 236) 100%);\n"
        "    background-image: -moz-linear-gradient(left , rgb(221, 221, 221) 0%, rgb(238, 238, 236) 100%);\n"
        "}\n"
        "h4 {\n"
        "    border-top: 1px solid rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "    border-bottom: 1px solid rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "    background-color: rgb(186, 189, 182); /* Oxygen aluminium gray3 */\n"
        "    /* Fade from aluminium gray4 to aluminium gray3 */\n"
        "    background-image: linear-gradient(left , rgb(136, 138, 133) 0%, rgb(186, 189, 182) 100%);\n"
        "    background-image: -webkit-linear-gradient(left , rgb(136, 138, 133) 0%, rgb(186, 189, 182) 100%);\n"
        "    background-image: -moz-linear-gradient(left , rgb(136, 138, 133) 0%, rgb(186, 189, 182) 100%);\n"
        "    color: white;\n"
        "}\n"
        ".table_of_contents {\n"
//         "    padding-left: 30px;\n"
        "}\n"
        ".class_details .brief_description_block {\n"
        "    margin-top: 0 !important;\n"
        "}\n"
        "h1.title {\n"
        "    color: rgb(156, 15, 15); /* Oxygen brickred6 */\n"
        "}\n"
        ".doxygen_titled_paragraph {\n"
        "    padding-left: 20px;\n"
        "    text-indent: -20px;\n"
        "    margin: 5px 0px;\n"
        "}\n"
        ".signature {\n"
        "    font-weight: normal;\n"
        "}\n"
        ".signature .name {\n"
        "    font-weight: bold;\n"
        "}\n"
        ".overview .method {\n"
        "    margin-bottom: 5px;\n"
        "}\n"
        ".overview .method .signature {\n"
        "    padding: 2px 5px 2px 20px;\n"
        "    text-indent: -20px;\n"
        "}\n"
        ".overview .method_name {\n"
        "    font-weight: bold;\n"
        "    text-decoration: none;\n"
        "}\n"
        ".parameter_list {\n"
        "    font-size: 0.9em;\n"
        "}\n"
        ".parameter_list .parameter_type {\n"
        "    color: rgb(216, 232, 194); /* Oxygen forest green1 */\n"
        "}\n"
        ".parameter_list .parameter_name {\n"
        "    font-weight: normal;\n"
        "}\n"
        ".return_type {\n"
        "    color: rgb(216, 232, 194); /* Oxygen forest green1 */\n"
        "}\n"
        ".overview .return_type {\n"
        "    color: rgb(0, 88,  63); /* Oxygen emerald green6 */\n"
        "}\n"
        ".overview .parameter_type {\n"
        "    color: rgb(0, 88,  63); /* Oxygen emerald green6 */\n"
        "}\n"
        ".overview .method .brief_description {\n"
        "    display: none; /* Currently not shown, but in a tooltip */\n"
        "    padding: 2px 15px;\n"
        "    color: rgb(85, 85, 85); /* Oxygen gray5 */\n"
        "}\n"
        ".class_details a {\n"
        "    color: rgb(0, 67, 138); /* Oxygen skyblue5 */\n"
        "    text-decoration: none;\n"
        "}\n"
        "a.back_to_top_link {\n"
        "    color: rgb(0, 87, 174); /* Oxygen skyblue4 */\n"
        "    display: block;\n"
        "    text-decoration: none;\n"
        "    text-align: right;\n"
        "}\n"
        "a.back_to_toc, a.back_to_home {\n"
        "    color: rgb(44, 114, 199); /* Oxygen skyblue3 */\n"
        "    display: block;\n"
        "    float: right;\n"
        "    vertical-align: middle;\n"
        "    text-decoration: none;\n"
        "    font-size: 0.65em;\n"
        "    margin-top: 0.5em;\n"
        "    font-weight: normal;\n"
        "}\n"
        ".method_details .method {\n"
        "    border: 1px solid rgb(221, 221, 221); /* Oxygen gray2 */\n"
        "    background-color: rgb(238, 238, 236); /* Oxygen gray1 */\n"
        "    margin: 10px 0px;\n"
        "    padding: 6px;\n"
        "}\n"
        ".method_details .method .signature {\n"
        "    margin: 0 -11px; /* the (-)11 equals padding of '.overview, .class_details, ...' */\n"
        "    font-size: 1.15em;\n"
        "    padding: 5px 5px 5px 35px;\n"
        "    text-indent: -20px;\n"
        "}\n"
        ".method_details .method .signature a {\n"
        "    color: rgb(164, 192, 228); /* Oxygen sky blue1 */\n"
        "}\n"
        ".object_name {\n"
        "}\n"
        ".brief_description_block {\n"
        "    font-weight: bold;\n"
        "    margin-top: 12px !important;\n"
        "    margin-bottom: 12px !important;\n"
        "    border-bottom: 1px solid rgb(221, 221, 221); /* Oxygen gray2 */\n"
        "}\n"
        ".brief_description_block .title {\n"
        "    display: none; /* Hide title (\"Brief:\") for brief comments */\n"
        "}\n"
        ".parameter_description_block {\n"
        "}\n"
        ".parameter_name {\n"
        "    font-weight: bold;\n"
        "}\n"
        ".parameter_description {\n"
        "}\n"
        ".return_value_description_block {\n"
        "}\n"
        ".return_value_description {\n"
        "}\n"
        ".description_block {\n"
        "    display: block;\n"
        "    margin-top: 10px;\n"
        "    margin-left: 15px;\n"
        "}\n"
        ".description_block div, .class_details div {\n"
        "    margin-bottom: 5px;\n"
        "}\n"
        ".description_block ul {\n"
        "    margin: 1;\n"
        "    padding-left: 22px;\n"
        "}\n"
        ".description {\n"
        "    margin-left: 0px;\n"
        "}\n"
        ".description_code {\n"
        "    font-family: monospace;\n"
        "    display: inline-block;\n"
        "    margin-left: 10px;\n"
        "    margin-bottom: 10px;\n"
        "    padding: 5px 15px;\n"
        "    background-color: rgb(255, 217, 176); /* Oxygen hot orange1 */\n"
        "    border: 1px solid rgb(242, 187, 136); /* Oxygen hot orange2 */\n"
        "}\n"
        ".enumerables li {\n"
        "    margin-bottom: 5px;\n"
        "    padding-bottom: 5px;\n"
        "    border-bottom: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "}\n"
        ".enumerables .description {\n"
        "    border-bottom: 1px solid rgb(187, 187, 187); /* Oxygen gray3 */\n"
        "    margin-bottom: 5px;\n"
        "}\n"
        ".enumerables .doxygen_titled_paragraph, .enumerables .comment_paragraph {\n"
        "    display: inline;\n"
        "    padding-left: 0;\n"
        "}\n"
        ".enumerable_name {\n"
        "    font-weight: bold;\n"
        "}\n"
        ".enumerable_value {\n"
        "    font-weight: normal;\n"
        "    font-size: 0.8em;\n"
        "}\n"
        ".enumerable_value:before { content: \"(\" }\n"
        ".enumerable_value:after { content: \")\" }\n"
        ".code_comment {\n"
        "    color: rgb(0, 137, 44); /* Oxygen forest green5 */\n"
        "}\n"
        ".code_comment a {\n"
        "    color: rgb(0, 110, 41); /* Oxygen forest green6 */\n"
        "}\n"
        ".code_string a {\n"
        "    color: rgb(156, 15, 15); /* Oxygen brick red6 */\n"
        "}\n"
        "/* Do not apply \"code_keyword\", \"code_string\" classes\n"
        " * in eg. \"code_comment\" class, only for direct children of .verbatim */\n"
        ".verbatim > .code_keyword {\n"
        "    font-weight: bold;\n"
        "}\n"
        ".verbatim > .code_string {\n"
        "    color: rgb(191, 3, 3); /* Oxygen brick red5 */\n"
        "}\n"
        ".verbatim > .code_number {\n"
        "    color: rgb(191, 3, 3); /* Oxygen brick red5 */\n"
        "}\n"
        ".verbatim {\n"
        "    font-family: monospace;\n"
        "    white-space: pre;\n"
        "}\n")
        .arg(OUTPUT_FILE_GENERATOR_COMMENT).arg(timeString).toUtf8() );
    output.close();
    return true;
}

void OutputGenerator::writeHtmlPrefix( QIODevice *dev, const QString &title,
                                       const QString &cssFileName )
{
    const QString timeString = QDateTime::currentDateTime().toString();
    dev->write( QString(
        "<!-- %1\n"
        "     Time: %2 -->\n"
        "\n"
        "<html>\n"
        "    <head>\n"
        "        <title>%4</title>\n"
        "        <link rel=\"stylesheet\" href=\"%3\" type=\"text/css\" />\n"
        "    </head>\n"
        "<body>\n")
        .arg(OUTPUT_FILE_GENERATOR_COMMENT).arg(timeString).arg(cssFileName).arg(title).toUtf8() );

}

void OutputGenerator::writeHtmlPostfix( QIODevice *dev )
{
    dev->write( "\n</body>\n" );
    dev->close();
}

QString OutputGenerator::fileNameFromClassDocumentation( const ClassInformation &classInformation )
{
    return classInformation.className.toLower() + ".html";
}

bool OutputGenerator::writeHtmlOutput( const QString &outputDirectory,
                                       const QString &htmlHomeFileName,
                                       const QString &cssFileName,
                                       const ClassInformationList &classInformationList,
                                       const Comments &globalComments,
                                       const EnumCommentList &enumComments )
{
    m_generator->setClassInformation( classInformationList );
    m_generator->buildTableOfContents( globalComments );
    const TableOfContentsEntries entries = m_generator->tableOfContents();

    QString tableOfContents = "<div class=\"table_of_contents\" id=\"toc\"><h2>Table Of Contents</h2><ul>\n";
    foreach ( const TableOfContentsEntry &entry, entries ) {
        tableOfContents += QString("    <li><a href=\"#%1\">%2</a></li>\n")
                           .arg(entry.id).arg(entry.title);

        if ( !entry.subEntries.isEmpty() ) {
            tableOfContents += "    <ul class=\"toc_sub_entry_list\">\n";
            foreach ( const TableOfContentsEntry &subEntry, entry.subEntries ) {
                tableOfContents += QString("        <li><a href=\"#%1\">%2</a></li>\n")
                                .arg(subEntry.id).arg(subEntry.title);
            }
            tableOfContents += "    </ul>\n";
        }
    }
    tableOfContents += "    <li>Class Documentation</li>\n"
                       "    <ul class=\"toc_class_files toc_sub_entry_list\">\n";
    foreach ( const ClassInformation &classInformation, classInformationList ) {
        const QString fileName = fileNameFromClassDocumentation( classInformation );
        tableOfContents += QString("    <li><a href=\"%1\" title=\"%3\">%2</a></li>\n")
                           .arg( fileName ).arg( classInformation.className )
                           .arg( classInformation.comment.brief );
    }
    tableOfContents += "    </ul>\n"
                       "    <li><a href=\"enums.html\">Enumerations</a></li>\n"
                       "</ul><br />\n";

    foreach ( const EnumComment enumComment, enumComments ) {
        m_generator->addEnumerationReference( enumComment.name );
        for ( EnumerableComments::ConstIterator it = enumComment.enumerables.constBegin();
              it != enumComment.enumerables.constEnd(); ++it )
        {
            m_generator->addEnumerableReference( enumComment.name, it->name );
        }
    }

    // Write documentation home
    const QString htmlFilePath = outputDirectory + '/' + htmlHomeFileName;
    QFile output;
    if ( !openGenerationFile(htmlFilePath, &output) ) {
        return false;
    }
    writeHtmlPrefix( &output, "PublicTransport Data Engine - Script API Documentation", cssFileName );
    output.write( tableOfContents.toUtf8() );
    output.write( commentListToOutput(globalComments, true).toUtf8() );
    writeHtmlPostfix( &output );

    // Write class documentation pages
    foreach( const ClassInformation &classInformation, classInformationList ) {
        const QString classHtmlFilePath = outputDirectory + '/' +
                 fileNameFromClassDocumentation( classInformation );
        if ( !openGenerationFile(classHtmlFilePath, &output) ) {
            return false;
        }
        writeHtmlPrefix( &output, "PublicTransport Script API Class " + classInformation.className,
                         cssFileName );
        writeHtmlClassDocumentation( &output, classInformation );
        writeHtmlPostfix( &output );
    }

    // Write enumeration documentation page
    const QString enumHtmlFilePath = outputDirectory + "/enums.html";
    if ( !openGenerationFile(enumHtmlFilePath, &output) ) {
        return false;
    }
    writeHtmlPrefix( &output, "PublicTransport Script API Enumerations", cssFileName );
    output.write( "<div class=\"enumerations\">\n" );
    foreach ( const EnumComment enumComment, enumComments ) {
        output.write( enumCommentToOutput(enumComment).toUtf8() );
    }
    output.write( "</div>\n" );
    writeHtmlPostfix( &output );
    return true;
}

QStringList OutputGenerator::splitLongTextToMultipleLines( const QString &string, int maxColumns )
{
    // Split string at new lines, but try to avoid splitting at new lines in quotes,
    // currently it only works with a single "\n" in quotes
    QString s = string;
    QStringList oldLines = s.replace("\"\n\"", "%NEWLINE_STRING%")
                            .split( "\n" );
    QStringList lines;
    foreach ( const QString &oldLine, oldLines ) {
        int lastPos = 0;
        int lineNr = 1;
        QString realOldLine = oldLine;
        realOldLine.replace("%NEWLINE_STRING%", "\"\n\"");
        while ( realOldLine.length() > maxColumns ) {
            int pos = realOldLine.lastIndexOf( ' ', lineNr * maxColumns );
            if ( pos < lastPos ) {
                break;
            } else {
                lines << realOldLine.mid( lastPos, pos - lastPos + 1 );
                ++lineNr;
                lastPos = pos + 1;
            }
        }
        lines << realOldLine.mid( lastPos );
    }
    return lines;
}

void OutputGenerator::writeAddCompletionsImplementation(
        QIODevice *dev, const ClassInformation &classInformation )
{
    foreach( const Method &method, classInformation.methods ) {
        // Output for completion
        QString description = QString( "<b>Brief:</b> %1" )
                .arg( transform(method.comment.brief) );
        const QString newLine = "<br />\"\n            \"";

        // Add other comment blocks
        foreach ( const DoxygenComment *comment, method.comment.otherComments ) {
            QString title;
            Transformations transformations = DefaultTransformations;
            switch ( comment->type() ) {
            case DoxygenSee:
                title = "See Also";
                transformations |= TransformAllReferences;
                break;
            case DoxygenNote:
                title = "Note";
                break;
            case DoxygenSince:
                title = "Since";
                break;
            case DoxygenWarning:
                title = "Warning";
                break;
            case DoxygenTodo:
                title = "To do";
                break;
            case DoxygenDeprecated:
                title = "Deprecated";
                break;
            case DoxygenBug:
                title = "Bug";
                break;
            default:
                break;
            }

            QString commentText = transform( comment->comment(), transformations );
            commentText = splitLongTextToMultipleLines( commentText ).join( "\"\n            \"" );
            if ( title.isEmpty() ) {
                description += newLine + commentText;
            } else {
                description += newLine +
                        QString("<p class='doxygen_titled_paragraph'><b>%1:</b>&nbsp;%2</p>")
                        .arg( title ).arg( commentText );
            }
        }

        // Add parameter description block
        if ( !method.comment.parameters.isEmpty() ) {
            description += newLine + "<b>Parameters:</b><ul>\"\n            \"";
            foreach ( const DoxygenParameter *parameter, method.comment.parameters ) {
                QString parameterCommentText = transform( parameter->comment() );
                parameterCommentText = splitLongTextToMultipleLines( parameterCommentText )
                        .join( "\"\n            \"" );
                description += QString("<li><b>%1</b> %2</li>\"\n            \"")
                        .arg( parameter->arguments.first() )
                        .arg( parameterCommentText );
            }
            description += "</ul></div>";
        }

        // Add return value description block
        if ( !method.comment.returns.isEmpty() ) {
            QString returnCommentText = transform( method.comment.returns );
            returnCommentText = splitLongTextToMultipleLines( returnCommentText )
                    .join( "\"\n            \"" );
            description += QString( newLine + "<b>Return Value:</b> %1")
                    .arg( returnCommentText );
        }

        const QString newOutput = QString(
                "    // Completion for %1.%2()\n"
                "    completions->operator[](\"%1\").insert( \"call:%2()\", CompletionItem(\n"
                "            KTextEditor::CodeCompletionModel::Function,\n"
                "            \"%2(%3)\",\n"
                "            \"%6\",\n"
                "            \"%2(%4);\", true, \"%5\") );\n" )
                .arg( classInformation.scriptObjectName )
                .arg( method.name )
                .arg( method.typedParameters.join(", ") )
                .arg( method.templatedParameters.join(", ") )
                .arg( method.returnType )
                .arg( description );
        dev->write( newOutput.toUtf8() );
    }

    dev->write( "\n" );
}

void OutputGenerator::writeAddAvailableMethodsImplementation(
        QIODevice *dev, const ClassInformation &classInformation )
{
    QString str;
    QString line = QString( "    methods->operator[](\"%1\") = QStringList()" )
                   .arg( classInformation.scriptObjectName );
    foreach( const QString &method, classInformation.methodNames ) {
        if( line.length() + method.length() + 16 > 100 ) {
            if( !str.isEmpty() ) {
                str += "\n            ";
            }
            str += line;
            line.clear();
        }
        line += QString( " << \"%1\"" ).arg( method );
    }
    if( !line.isEmpty() ) {
        if( !str.isEmpty() ) {
            str += "\n            ";
        }
        str += line;
    }
    str += ";\n";
    dev->write( str.toUtf8() );
}

QString AbstractGenerator::transform( const QString &input, Transformations transformations ) const
{
    QString output = input;
    if ( transformations.testFlag(TransformEncode) ) {
        output = encodeString( output );
    }
    if ( transformations.testFlag(TransformInlineMarkers) ) {
        output = replaceInlineMarkers( output );
    }
    if ( transformations.testFlag(TransformAllReferences) ) {
        output = transformAllReferences( output );
    } else if ( transformations.testFlag(TransformSureReferences) ) {
        output = transformSureReferences( output );
    }
    if ( transformations.testFlag(TransformHighlightCode) ) {
        output = highlightCodeSyntax( output );
    }
    if ( transformations.testFlag(TransformAddVisibilityToggle) ) {
        output = addVisibilityToggle( output );
    }
    if ( transformations.testFlag(TransformRemoveRemainingMarkers) ) {
        output = removeAllMakers( output );
    }
    return output;
}

void AbstractGenerator::addEnumerationReference( const QString &enumerationName )
{
    m_enumerableReferences.insert( enumerationName, enumerationName );
}

void AbstractGenerator::addEnumerableReference( const QString &enumerationName,
                                                const QString &enumerableName )
{
    m_enumerableReferences.insert( enumerableName,
                                   QString("%1-%2").arg(enumerationName).arg(enumerableName) );
}

QString OutputGenerator::enumCommentToOutput( const EnumComment &enumComment ) const
{
    Comment comment( enumComment.brief );
    comment.otherComments = enumComment.otherComments;
    QString text = QString("<h2 id=\"%1\">%1<a class=\"back_to_home\" title=\"Back to Home\" "
                "href=\"index.html\">Back to Home</a></h2><ul class=\"enumerables\">")
            .arg(enumComment.name) + commentToOutput( comment );
    for ( QList<EnumerableComment>::ConstIterator it = enumComment.sortedEnumerables.constBegin();
          it != enumComment.sortedEnumerables.constEnd(); ++it )
    {
        text += QString("<li><div class=\"enumerable_name\" id=\"%3-%1\">%1"
                " <span class=\"enumerable_value\">%2</span></div>")
                .arg( it->name ).arg( it->value ).arg( enumComment.name );

        if ( !it->brief.isEmpty() ) {
            text += "<span class=\"brief_description_block\">" + it->brief + "</span>";
        }
        text += commentToOutput( it->otherComments );
        text += QLatin1String("</li>");
    }
    text += QLatin1String("</ul>");
    return text;
}

QString OutputGenerator::commentListToOutput( const Comments &comments, bool ignoreBriefComment ) const
{
    QString text;
    foreach ( const Comment &comment, comments ) {
        if ( !text.isEmpty() ) {
            text += "\n\n";
        }
        text += commentToOutput( comment, ignoreBriefComment );
    }
    return text;
}

QString OutputGenerator::commentToOutput( const DoxygenComments &otherComments ) const
{
    QString description;
    foreach ( const DoxygenComment *otherComment, otherComments ) {
        QString title, cssClass;
        Transformations transformations = DefaultTransformations;
        switch ( otherComment->type() ) {
        case DoxygenSee:
            title = "See Also";
            cssClass = "title_see";
            transformations |= TransformAllReferences;
            break;
        case DoxygenNote:
            title = "Note";
            cssClass = "title_note";
            break;
        case DoxygenSince:
            title = "Since";
            cssClass = "title_since";
            break;
        case DoxygenWarning:
            title = "Warning";
            cssClass = "title_warning";
            break;
        case DoxygenTodo:
            title = "To do";
            cssClass = "title_todo";
            break;
        case DoxygenDeprecated:
            title = "Deprecated";
            cssClass = "title_deprecated";
            break;
        case DoxygenBug:
            title = "Bug";
            cssClass = "title_bug";
            break;
        default:
            break;
        }

        const QString transformed = transform( otherComment->comment(), transformations );
        if ( title.isEmpty() ) {
            if ( QString(transformed).remove(QRegExp("<br\\s*/?>")).trimmed().isEmpty() ) {
                // Comment only contains whitespaces
                description += transformed;
            } else {
                description += QString("<div class=\"comment_paragraph\">%1</div>\n")
                        .arg( transformed );
            }
        } else {
            description += QString(
                    "<div class=\"doxygen_titled_paragraph\">\n"
                    "  <span class=\"title %2\">%1:</span>&nbsp;%3</div>\n")
                    .arg( title )
                    .arg( cssClass )
                    .arg( transformed );
        }
    }

    return description;
}

QString OutputGenerator::commentToOutput( const Comment &comment, bool ignoreBriefComment ) const
{
    // Output for HTML documentation
    // The HTML code in description gets inserted into newOutput below
    QString description = comment.brief.isEmpty() || ignoreBriefComment
            ? QString() : QString(
            "<div class=\"brief_description_block\">\n"
            "                <span class=\"title\">Brief:</span>\n"
            "                %1\n"
            "            </div>\n")
            .arg( transform(comment.brief) );

    // Add other comment blocks
    if ( !comment.otherComments.isEmpty() ) {
        description += "            <div class=\"description\">\n"
                     + commentToOutput( comment.otherComments )
                     + "            </div>\n";
    }

    // Add parameter description block
    if ( !comment.parameters.isEmpty() ) {
        description += "            <div class=\"parameter_description_block\">\n"
                       "                <span class=\"title\">Parameters:</span>\n"
                       "                <ul>\n";
        foreach ( const DoxygenParameter *parameter, comment.parameters ) {
            description += QString(
                    "                    <li><span class=\"parameter_name\">%1</span>\n"
                    "                        <span class=\"parameter_description\">%2</span>\n"
                    "                    </li>\n" )
                    .arg( parameter->arguments.first() )
                    .arg( transform(parameter->comment()) );
        }
        description += "                </ul>\n"
                       "            </div>\n";
    }

    // Add return value description block
    if ( !comment.returns.isEmpty() ) {
        description += QString(
                "            <div class=\"return_value_description_block\">\n"
                "                <span class=\"title\">Return Value:</span>\n"
                "                <span class=\"return_value_description\">%1</span>\n"
                "            </div>\n")
                .arg( transform(comment.returns) );
    }

    return description;
}

void OutputGenerator::writeHtmlClassDocumentation( QIODevice *dev,
                                                   const ClassInformation &classInformation )
{
    QStringList methodList;
    int n = 0;
    foreach( const Method &method, classInformation.sortedMethods ) {
        const QString brief = transform( method.comment.brief );
        QString briefNoHtml = brief;
        briefNoHtml.remove( QRegExp("<\\/?[^>]+>") );
        const bool hasParameters = method.parameters.count();
        const QString parameterPadding = hasParameters ? "&nbsp;" : QString();
        if ( n == 0 && method.metaMethod.methodType() == QMetaMethod::Signal ) {
            methodList << "<h3>Signals</h3>\n";
            n = 1;
        } else if ( n == 1 && method.metaMethod.methodType() == QMetaMethod::Slot ) {
            methodList << "<h3>Slots</h3>\n";
            n = 2;
        }

        methodList << QString(
                "    <div class=\"method signature\">\n"
                "        <span class=\"return_type\">%5</span>\n"
                "        <a class=\"method_name\" href=\"#%1-%2\"\n"
                "           title=\"%7\">\n"
                "        %3</a>(<span class=\"parameter_list\">%4</span>)\n"
                "    </div>\n" )
                .arg( classInformation.scriptObjectName )
                .arg( method.name.toLower() )
                .arg( method.name )
                .arg( parameterPadding + parameterListOutput(method.typedParameters) +
                      parameterPadding )
                .arg( method.returnType )
                .arg( briefNoHtml );
    }

    dev->write( QString(
            "<!-- Overview of class %2 -->\n"
            "<h2 class=\"title\" id=\"%1\">Class %2\n"
            "<a class=\"back_to_home\" title=\"Back to Home\" "
                "href=\"index.html\">Back to Home</a></h2>\n"
            "<div class=\"overview\">\n"
            "<h3 class=\"title\">Method Overview</h3>\n"
            "%3\n"
            "</div>\n"
            "<!-- End: Overview of class %2 -->\n"
            "\n"
            "<!-- Detailed class documentation of %2 -->\n"
            "<div class=\"class_details\">\n"
            "<h3 class=\"title\">Class Details</h3>\n"
            "%4\n"
            "</div>\n"
            "<!-- EndDetailed class documentation of %2 -->\n"
            "\n"
            "<!-- Detailed method documentation of %2 -->\n"
            "<div class=\"method_details\">\n"
            "<h3 class=\"title\">Detailed Method Description</h3>\n")
            .arg( classInformation.scriptObjectName )
            .arg( classInformation.className )
            .arg( methodList.join("\n") )
            .arg( commentToOutput(classInformation.comment) ).toUtf8() );

    n = 0;
    foreach( const Method &method, classInformation.sortedMethods ) {
        if ( n == 0 && method.metaMethod.methodType() == QMetaMethod::Signal ) {
            dev->write( "<br /><h3>Signals</h3>\n" );
            n = 1;
        } else if ( n == 1 && method.metaMethod.methodType() == QMetaMethod::Slot ) {
            dev->write( "<br /><h3>Slots</h3>\n" );
            n = 2;
        }

        const bool hasParameters = method.parameters.count();
        const QString parameterPadding = hasParameters ? "&nbsp;" : QString();
        const QString newOutput = QString(
                "    <!-- Documentation for %1.%3() -->\n"
                "    <div class=\"method\">\n"
                "        <h4 class=\"signature\" id=\"%2-%4\">\n"
                "            <span class=\"return_type\">%6</span>\n"
                "            <span class=\"name\">%3</span>(<span class=\"parameter_list\">%5</span>)\n"
                "        </h4>\n"
                "        <div class=\"description_block\">\n"
                "            %7\n"
                "        </div>\n"
                "        <a href=\"#%2\" class=\"back_to_top_link\">back to top</a>\n"
                "    </div>\n\n" )
                .arg( classInformation.className )
                .arg( classInformation.scriptObjectName )
                .arg( method.name )
                .arg( method.name.toLower() )
                .arg( parameterPadding + parameterListOutput(method.typedParameters) +
                      parameterPadding )
                .arg( method.returnType )
                .arg( commentToOutput(method.comment) );
        dev->write( newOutput.toUtf8() );
    }

    dev->write( QString(
            "</div>\n"
            "<!-- End: Detailed method documentation of %2 -->\n"
            "<br />\n\n")
            .arg( classInformation.className ).toUtf8() );
}

void OutputGenerator::writeHtmlClassDocumentation(
        QIODevice *dev, const ClassInformationList &classInformationList )
{
    m_generator->setClassInformation( classInformationList );
    foreach( const ClassInformation &classInformation, classInformationList ) {
        writeHtmlClassDocumentation( dev, classInformation );
    }
}

QString OutputGenerator::parameterListOutput( QStringList typedParameters )
{
    QString parameters;
    foreach ( const QString &typedParameter, typedParameters ) {
        if ( !parameters.isEmpty() ) {
            parameters += ", ";
        }

        const int pos = typedParameter.indexOf(' ');
        Q_ASSERT( pos != -1 );
        const QString typeName = typedParameter.left( pos );
        const QString parameterName = typedParameter.mid( pos );

        // Create <span> tags for parameter type and name and do not break between type and name
        parameters += QString("<span class=\"parameter_type\">%1</span>&nbsp;"
                              "<span class=\"parameter_name\">%2</span>")
                      .arg(typeName).arg(parameterName);
    }
    return parameters;
}

QString AbstractGenerator::removeAllMakers( const QString &input ) const
{
    QString output = input;

    QLatin1String empty("");
    output = replaceInlineMarkerPair( output, DoxygenBold, empty, empty );
    output = replaceInlineMarkerPair( output, DoxygenItalic, empty, empty );
    output = replaceInlineMarkerPair( output, DoxygenInlineParam, empty, empty );
    output = replaceInlineMarkerPair( output, DoxygenImage, empty, empty );
    output = replaceInlineMarkerPair( output, DoxygenRef, empty, empty );
    output = removeSectionMarkerPair( output, DoxygenSection );
    output = removeSectionMarkerPair( output, DoxygenSubSection );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginVerbatim, empty, empty );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginCode, empty, empty );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginList, empty, empty );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginListItem, empty, empty );

    return output;
}

QString AbstractGenerator::replaceAllMarkers(
        const QString &input, const MarkerPair &marker, const MarkerPair &replacement,
        Transformations transformations ) const
{
    QString output = input;
    if ( transformations == NoTransformation ) {
        output.replace( marker.begin, replacement.begin )
              .replace( marker.end, replacement.end );
    } else {
        int pos = 0;
        while ( (pos = output.indexOf(marker.begin, pos)) != -1 ) {
            // Replace begin marker
            const int beginMarkerLength = strlen( marker.begin.latin1() );
            const int beginMarkerReplacementLength = strlen( replacement.begin.latin1() );
            output.replace( pos, beginMarkerLength, replacement.begin );
            pos += beginMarkerReplacementLength; // was at the beginning of the begin marker

            // Find end marker
            const int endPos = output.indexOf( marker.end, pos );
            if ( endPos == -1 ) {
                qWarning() << "No end marker found after begin marker at position" << pos;
                break;
            }

            // Transform text between the markers
            const int transformLength = endPos - pos;
            const QString markedInput = output.mid( pos, transformLength );
            const QString transformedInput = transform( markedInput, transformations );
            output.replace( pos, transformLength, transformedInput );
            pos += transformedInput.length();

            // Replace end marker
            const int endMarkerLength = strlen( marker.end.latin1() );
            const int endMarkerReplacementLength = strlen( replacement.end.latin1() );
            output.replace( pos, endMarkerLength, replacement.end );
            pos += endMarkerReplacementLength;
        }
    }

    return output;
}

QString AbstractGenerator::replaceInlineMarker(
        const QString &input, DoxygenCommandType type, const QLatin1String &markerReplacement ) const
{
    QString output = input;
    return output.replace( MarkerPair::fromCommand(type), markerReplacement );
}

QString AbstractGenerator::replaceInlineMarkerPair(
        const QString &input, DoxygenCommandType inlineType,
        const QLatin1String &beginMarkerReplacement, const QLatin1String &endMarkerReplacement,
        Transformations transformations ) const
{
    return replaceAllMarkers( input, MarkerPair::fromInlineCommand(inlineType),
            MarkerPair(beginMarkerReplacement, endMarkerReplacement),
            transformations );
}

void AbstractGenerator::buildTableOfContents( const Comments &comments )
{
    QString input;
    foreach ( const Comment &comment, comments ) {
        foreach ( const DoxygenComment *doxygenComment, comment.otherComments ) {
            input += doxygenComment->comment();
        }
    }

    const MarkerPair markerSection = MarkerPair::fromInlineCommand( DoxygenSection );
    const MarkerPair markerSubSection = MarkerPair::fromInlineCommand( DoxygenSubSection );
    int pos = 0, pos2 = 0;
    forever {
        pos = input.indexOf( markerSection.begin, pos );
        pos2 = input.indexOf( markerSubSection.begin, pos2 );
        if ( pos == -1 && pos2 == -1 ) {
            break;
        }

        const MarkerPair *marker;
        bool isSubSection = (pos2 < pos && pos2 != -1) || pos == -1;
        if ( isSubSection ) {
            marker = &markerSubSection;
            pos = pos2;
        } else {
            marker = &markerSection;
            pos2 = pos;
        }

        const int beginMarkerLength = strlen( marker->begin.latin1() );
        pos += beginMarkerLength + 3; // was at the beginning of the begin marker
        const int idPos = pos;
        const int idEndPos = input.indexOf( '%', idPos );
        Q_ASSERT( idEndPos != -1 );
        const QString sectionId = input.mid( idPos, idEndPos - idPos );
        pos += sectionId.length() + 1;
        pos2 = pos;

        // Find end marker
        const int endPos = input.indexOf( marker->end, pos );
        if ( endPos == -1 ) {
            qWarning() << "No end marker found after begin marker at position" << pos;
            break;
        }

        // Get title, ie. text between begin and end marker
        const QString title = input.mid( pos, endPos - pos ).trimmed();
//         pos += title.length() + strlen(marker->end.latin1());

        if ( isSubSection ) {
            // Add sub section to last main section
            if ( m_tableOfContents.isEmpty() ) {
                qDebug() << "@subsection used without a @section";
                m_tableOfContents << TableOfContentsEntry( sectionId, title, isSubSection );
            } else {
                m_tableOfContents.last().subEntries <<
                        TableOfContentsEntry( sectionId, title, isSubSection );
            }
        } else {
            m_tableOfContents << TableOfContentsEntry( sectionId, title, isSubSection );
        }
    }
}

QString AbstractGenerator::replaceSectionMarkerPair(
        const QString &input, DoxygenCommandType sectionType,
        const QLatin1String &beginMarkerReplacement, const QLatin1String &endMarkerReplacement,
        Transformations transformations ) const
{
    const MarkerPair marker = MarkerPair::fromInlineCommand( sectionType );
    const MarkerPair replacement = MarkerPair( beginMarkerReplacement, endMarkerReplacement );
    QString output = input;
    const int beginMarkerLength = strlen( marker.begin.latin1() );
    const int endMarkerLength = strlen( marker.end.latin1() );
    const int endMarkerReplacementLength = strlen( replacement.end.latin1() );
    int pos = 0;
    while ( (pos = output.indexOf(marker.begin, pos)) != -1 ) {
        // Replace begin marker
        Q_ASSERT ( output.mid(pos + beginMarkerLength, 3) == QLatin1String("ID=") );
        const int idPos = pos + beginMarkerLength + 3;
        const int idEndPos = output.indexOf( '%', idPos );
        Q_ASSERT( idEndPos != -1 );
        const QString sectionId = output.mid( idPos, idEndPos - idPos );
        const QString replacementBegin = QString( replacement.begin ).arg( sectionId );
        output.replace( pos, beginMarkerLength + sectionId.length() + 4, // +4 = "ID=" (3) + "%" (1)
                        replacementBegin );
        pos += replacementBegin.length(); // was at the beginning of the begin marker

        // Find end marker
        const int endPos = output.indexOf( marker.end, pos );
        if ( endPos == -1 ) {
            qWarning() << "No end marker found after begin marker at position" << pos;
            break;
        }

        // Transform text between the markers
        const int transformLength = endPos - pos;
        const QString markedInput = output.mid( pos, transformLength );
        const QString transformedInput = transform( markedInput, transformations );
        output.replace( pos, transformLength, transformedInput );
        pos += transformedInput.length();

        // Replace end marker
        output.replace( pos, endMarkerLength, replacement.end );
        pos += endMarkerReplacementLength;
    }

    return output;
}

QString AbstractGenerator::removeSectionMarkerPair( const QString &input,
                                                    DoxygenCommandType sectionType ) const
{
    QString output = input;
    const MarkerPair marker = MarkerPair::fromInlineCommand( sectionType );
    const int beginMarkerLength = strlen( marker.begin.latin1() );
    int pos = 0;
    while ( (pos = output.indexOf(marker.begin, pos)) != -1 ) {
        Q_ASSERT ( output.mid(pos + beginMarkerLength, 3) == QLatin1String("ID=") );
        const int idPos = pos + beginMarkerLength + 3;
        const int idEndPos = output.indexOf( '%', idPos );
        Q_ASSERT( idEndPos != -1 );
        output.remove( pos, idEndPos - idPos );
    }

    return output;
}

QString AbstractGenerator::replaceInlineMarkerPair(
        const QString &input, DoxygenCommandType inlineType, Transformations transformations ) const
{
    QLatin1String empty("");
    return replaceAllMarkers( input, MarkerPair::fromInlineCommand(inlineType),
            MarkerPair(empty, empty), transformations );
}

QString AbstractGenerator::replaceBeginEndMarkerPair(
        const QString &input, DoxygenCommandType beginType,
        const QLatin1String &beginMarkerReplacement, const QLatin1String &endMarkerReplacement,
        Transformations transformations ) const
{
    Q_ASSERT_X( flagsFromCommand(beginType).testFlag(DoxygenCommandBegin),
                "AbstractGenerator::replaceBeginEndCommandMarkers",
                "Only begin commands are allowed here, ie those with flag DoxygenCommandBegin" );
    return replaceAllMarkers( input, MarkerPair::fromBeginCommand(beginType),
            MarkerPair(beginMarkerReplacement, endMarkerReplacement),
            transformations );
}

QString AbstractGenerator::replaceBeginEndMarkerPair(
        const QString &input, DoxygenCommandType beginType, Transformations transformations ) const
{
    Q_ASSERT_X( flagsFromCommand(beginType).testFlag(DoxygenCommandBegin),
                "AbstractGenerator::replaceBeginEndCommandMarkers",
                "Only begin commands are allowed here, ie those with flag DoxygenCommandBegin" );
    QLatin1String empty("");
    return replaceAllMarkers( input, MarkerPair::fromBeginCommand(beginType),
            MarkerPair(empty, empty), transformations );
}

QString AbstractGenerator::highlightCodeSyntax( const QString &input ) const
{
    QRegExp commentRegExp( "(//[^\n]*\n|/\\*.*\\*/)" );
    QRegExp keywordRegExp( "\\b(var|new|continue|break|return|if|else|for|while|do|function|true|false)\\b" );
    QRegExp stringRegExp( "(\"[^\"\n]*\"|'[^'\n]*'|/[^/\n]+/i?g?[\\s\\.;])" );
    QRegExp numberRegExp( "(\\b\\d+\\b)" );
    QString output = input;
    output.replace( '>', QLatin1String("&gt;") )
          .replace( '<', QLatin1String("&lt;") )
          .replace( stringRegExp, "<span class=\"code_string\">\\1</span>" )
          .replace( numberRegExp, "<span class=\"code_number\">\\1</span>" )
          .replace( commentRegExp, "<span class=\"code_comment\">\\1</span>" )
          .replace( keywordRegExp, "<span class=\"code_keyword\">\\1</span>" );

    return output;
}

QString AbstractGenerator::addVisibilityToggle( const QString &input ) const
{
    return input;
//     TODO
//     QString output = QString(
//             "<div class=\"toggle_contents\">\n"
//             "    %1\n"
//             "</div>\n"
//             // TODO
//             "<div class=\"toggle_button\" onclick=\"this.previousSibling.data='';return; var h=this.previousSibling.style.height;this.previousSibling.style.height=h!='30px'?'30px':'100px'\">\n"
//             "    \n"
//             "</div>").arg( input );
//     return output;
}

QString AbstractGenerator::encodeHtmlEntities( const QString &input ) const
{
    //lt|gt|
    QRegExp entityRegExp( "&(nbsp|amp|szlig|auml|Auml|ouml|Ouml|uuml|Uuml|#[0-9]+);" );
    QString output = input;
    int pos = 0;
    while ( (pos = entityRegExp.indexIn(output, pos)) != -1 ) {
        output.replace( pos, entityRegExp.matchedLength() - 1,
                        QString("&amp;%1").arg(entityRegExp.cap(1)) );
        pos += entityRegExp.matchedLength() + 4; // skip four inserted characters, ie. "&" => "&amp;"
    }
    return output;
}

void AbstractGenerator::setClassInformation( const ClassInformationList &classInformationList )
{
    foreach ( const ClassInformation &classInformation, classInformationList ) {
        m_classInformations.insert( classInformation.scriptObjectName, classInformation );
    }
}

QString DocumentationOutputGenerator::encodeString( const QString &input ) const
{
    return encodeHtmlEntities( input );
}

QString CompletionOutputGenerator::encodeString( const QString &input ) const
{
    return QString( input ).replace( QLatin1String( "\"" ), QLatin1String( "\\\"" ) )
                           .replace( '\n', QLatin1String("\"\n\"") );
}

QString DocumentationOutputGenerator::transformReferences( const QString &input,
                                                           ReferenceTypes referenceTypes ) const
{
    if ( m_classInformations.isEmpty() ) {
        qDebug() << "No class information given to DocumentationOutputGenerator";
        return input;
    }

    // Matches three things: Method name, scope and parentheses. Scope can be matched
    // like this: "class::method" or this: "class.method".
    QString pattern;
    const QLatin1String namePattern("[A-Za-z_][A-Za-z0-9_]*"); // Used as method/scope name
    const QString scopePattern = "\\b(?:(" + namePattern + ")(\\.|::))";
    const QLatin1String bracketPattern("(?:\\(|\\.[A-Za-z_])"); // The "\\.[A-Za-z_]" is for use of signals in QtScript
    const bool scoped = referenceTypes.testFlag( ScopedReferences );
    const bool bracketed = referenceTypes.testFlag( ReferencesWithBrackets );
    if ( scoped && bracketed ) {
        // Find scoped OR bracketed references
        // Examples: "class::function", "class.function", "class.function()", "function()"
        pattern = QString("(?:%1?(%2)%3|%1(%2))")
                .arg( scopePattern ).arg( namePattern ).arg( bracketPattern );
    } else if ( scoped ) {
        // Only find scoped references (may or may not be bracketed)
        // Examples: "class::function", "class.function", "class.function()"
        pattern = QString("%1(%2)").arg( scopePattern ).arg( namePattern );
    } else if ( bracketed ) {
        // Find bracketed references, use scope if given
        // Examples: "class.function()", "function()"
        pattern = QString("%1?(%2)%3")
                .arg( scopePattern ).arg( namePattern ).arg( bracketPattern );
    } else {
        // Find references only by name (may or may not be bracketed), use scope if given
        // Examples: "class::function", "class.function", "class.function()", "function()"
        pattern = QString("%1?(%2)").arg( scopePattern ).arg( namePattern );
    }

    QRegExp referenceRegExp( pattern );
    QString output = input;
    int pos = 0;
    while ( (pos = referenceRegExp.indexIn(output, pos)) != -1 ) {
        const QString scope = referenceRegExp.cap(1).isEmpty()
                ? referenceRegExp.cap(4) : referenceRegExp.cap(1);
        const QString scopeChar = referenceRegExp.cap(2).isEmpty()
                ? referenceRegExp.cap(5) : referenceRegExp.cap(2);
        const QString methodName = referenceRegExp.cap(3).isEmpty()
                ? referenceRegExp.cap(6) : referenceRegExp.cap(3);
        for ( ClassInformationListByName::ConstIterator it = m_classInformations.constBegin();
              it != m_classInformations.constEnd(); ++it )
        {
            const Method method = it->methods.findByMethodName( methodName );
            if ( method.isValid() &&
                 (scope.isEmpty() || scope.compare(it->scriptObjectName, Qt::CaseInsensitive) == 0
                                  || scope.compare(it->className, Qt::CaseInsensitive) == 0) )
            {
                QString replacement;
                if ( scope.isEmpty() ) {
                    replacement = QString("<a href=\"%1#%2-%3\" title=\"%5\">%4</a>")
                        .arg( OutputGenerator::fileNameFromClassDocumentation(it.value()) )
                        .arg( it->scriptObjectName )
                        .arg( methodName.toLower() )
                        .arg( methodName )
                        .arg( removeAllMakers(/*it->methods[methodName]*/method.comment.brief) );
                } else {
                    replacement = QString("<a href=\"%1#%3\" title=\"%7\">%2</a>%6<a href=\"%1#%3-%4\" title=\"%8\">%5</a>")
                        .arg( OutputGenerator::fileNameFromClassDocumentation(it.value()) )
                        .arg( scope.isEmpty() ? it->scriptObjectName : scope )
                        .arg( it->scriptObjectName )
                        .arg( methodName.toLower() )
                        .arg( methodName )
                        .arg( scopeChar )
                        .arg( removeAllMakers(it->comment.brief) )
                        .arg( removeAllMakers(/*it->methods[methodName]*/method.comment.brief) );
                }
                const int replacementLength = scope.length() + scopeChar.length() + methodName.length();
                output.replace( pos, replacementLength, replacement );
                pos += replacement.length() - referenceRegExp.matchedLength();
            }
        }
        pos += referenceRegExp.matchedLength();
    }

    pos = 0;
    QRegExp enumerableRegExp( "(?:@ref\\s*)?\\b(" + namePattern + ")" );
    while ( (pos = enumerableRegExp.indexIn(output, pos)) != -1 ) {
        const QString enumerableName = enumerableRegExp.cap( 1 );
        if ( m_enumerableReferences.contains(enumerableName) ) {
            // Test if enumeration name is part of reference link
            if ( pos > 0 && output[pos - 1] == '#' ) {
                pos += enumerableRegExp.matchedLength();
                continue;
            }

            // Test if enumerable is already referenced
            const QString testString = QString("\">%1</a>").arg(enumerableName);
            if ( output.mid(pos + enumerableRegExp.matchedLength(), testString.length())
                 == testString )
            {
                pos += testString.length();
                continue;
            }

            const QString replacement = QString("<a href=\"enums.html#%1\">%2</a>")
                    .arg(m_enumerableReferences[enumerableName]).arg(enumerableName);
            output.replace( pos, enumerableRegExp.matchedLength(), replacement );
            pos += replacement.length() - enumerableRegExp.matchedLength();
        }
        pos += enumerableRegExp.matchedLength();
    }

    return output;
}

QString DocumentationOutputGenerator::replaceInlineMarkers( const QString &input ) const
{
    QString output = input;

    output = replaceInlineMarker( output, DoxygenNewline, QLatin1String("<br />") );
    output = replaceInlineMarkerPair( output, DoxygenBold, QLatin1String("<b>"),
                                      QLatin1String("</b>") );
    output = replaceInlineMarkerPair( output, DoxygenItalic, QLatin1String("<i>"),
                                      QLatin1String("</i>") );
    output = replaceInlineMarkerPair( output, DoxygenInlineParam, QLatin1String("<i>"),
                                      QLatin1String("</i>") );
    output = replaceInlineMarkerPair( output, DoxygenImage, QLatin1String("<img src=\""),
                                      QLatin1String("\" />") ); // TODO
    output = replaceInlineMarkerPair( output, DoxygenRef, TransformAllReferences );

    output = replaceSectionMarkerPair( output, DoxygenSection, QLatin1String("<h2 id=\"%1\">"),
                                       QLatin1String("<a class=\"back_to_toc\" "
                                                     "title=\"Back to Table Of Contents\" "
                                                     "href=\"#toc\">Table Of Contents</a></h2>") );
    output = replaceSectionMarkerPair( output, DoxygenSubSection, QLatin1String("<h3 id=\"%1\">"),
                                       QLatin1String("</h3>") );

    output = replaceBeginEndMarkerPair( output, DoxygenBeginVerbatim,
                                        QLatin1String("<span class=\"verbatim\">"),
                                        QLatin1String("</span>"), TransformHighlightCode );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginCode,
                                        QLatin1String("<div class=\"verbatim\">"),
                                        QLatin1String("</div>"),
                                        TransformHighlightCode | TransformAddVisibilityToggle );

    output = replaceBeginEndMarkerPair( output, DoxygenBeginList, QLatin1String("<ul>"),
                                        QLatin1String("</ul>") );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginListItem, QLatin1String("<li>"),
                                        QLatin1String("</li>") );

    return removeAllMakers( output );
}

QString CompletionOutputGenerator::replaceInlineMarkers( const QString &input ) const
{
    QString output = input;

    output = replaceInlineMarker( output, DoxygenNewline, QLatin1String("<br />") );
    output = replaceInlineMarkerPair( output, DoxygenBold, QLatin1String("<b>"),
                                      QLatin1String("</b>") );
    output = replaceInlineMarkerPair( output, DoxygenItalic, QLatin1String("<i>"),
                                      QLatin1String("</i>") );
    output = replaceInlineMarkerPair( output, DoxygenInlineParam, QLatin1String("<i>"),
                                      QLatin1String("</i>") );
    output = replaceSectionMarkerPair( output, DoxygenSection, QLatin1String("<h2 id=\"%1\">"),
                                       QLatin1String("</h2>") );
    output = replaceSectionMarkerPair( output, DoxygenSubSection, QLatin1String("<h3 id=\"%1\">"),
                                       QLatin1String("</h3>") );

    output = replaceBeginEndMarkerPair( output, DoxygenBeginVerbatim, QLatin1String("<pre>"),
                                        QLatin1String("</pre>") );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginCode, QLatin1String("<pre>"),
                                        QLatin1String("</pre>") );

    output = replaceBeginEndMarkerPair( output, DoxygenBeginList, QLatin1String("<ul>"),
                                        QLatin1String("</ul>") );
    output = replaceBeginEndMarkerPair( output, DoxygenBeginListItem, QLatin1String("<li>"),
                                        QLatin1String("</li>") );

    return removeAllMakers( output );
}
