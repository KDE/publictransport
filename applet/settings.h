/*
 *   Copyright 2011 Friedrich Pülz <fpuelz@gmx.de>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Library General Public License as
 *   published by the Free Software Foundation; either version 2 or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this program; if not, write to the
 *   Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

/** @file
 * @brief This file contains classes for managing settings of the PublicTransport applet.
 * @author Friedrich Pülz <fpuelz@gmx.de> */

#ifndef SETTINGS_HEADER
#define SETTINGS_HEADER

// UI includes
#include "ui_publicTransportConfig.h"
#include "ui_publicTransportConfigAdvanced.h"
#include "ui_publicTransportFilterConfig.h"
#include "ui_publicTransportAppearanceConfig.h"
#include "ui_alarmConfig.h"

// Own includes
#include "global.h"
#include "journeysearchitem.h"

// libpublictransporthelper includes
#include <filter.h>
#include <stopsettings.h>

// Plasma includes
#include <Plasma/DataEngine>

class KConfigDialog;
class Settings;
class JourneySearchModel;

namespace Timetable {
    class LocationModel;
    class ServiceProviderModel;
    class StopListWidget;
};
using namespace Timetable;

/** @brief Different types of alarms. */
enum AlarmType {
    AlarmRemoveAfterFirstMatch = 0, /**< The alarm will get removed once fired. */
    AlarmApplyToNewDepartures /**< The alarm won't be removed automatically,
            * ie. it's a recurring alarm. */
};

/** @brief Contains information about an alarm. */
struct AlarmSettings {
    AlarmSettings( const QString &name = "<unnamed>", bool autoGenerated = false ) {
        this->name = name;
        this->autoGenerated = autoGenerated;
        this->enabled = true;
        this->type = AlarmRemoveAfterFirstMatch;
    };

    QString name; /**< The name of this alarm. */
    bool enabled; /**< Whether or not this alarm is enabled. */
    bool autoGenerated; /**< Whether or not this alarm is auto generated.
            * Alarms that get changed are no longer treated as auto generated. */
    Filter filter; /**< The filter to match alarm departures/arrivals. */
    AlarmType type; /**< The type of this alarm. */
    QList< int > affectedStops; /**< A list of stop settings indices for which
            * this alarm should be applied. */
    QDateTime lastFired; /**< The time when this alarm was last fired. */

    /**
     * @brief Compares this alarm with @p other without checking the name or target constraints.
     *
     * @param other The other alarm to compare with.
     *
     * @return bool True, if the alarms are "equal", ie. both autogenerated and equal except
     *   for the name/affectedStops/lastFired settings and without target constraints in the
     *   filter of this alarm.
     **/
    bool equalsAutogeneratedAlarm( const AlarmSettings &other );
};
bool operator ==( const AlarmSettings &l, const AlarmSettings &r );

/** @brief A QList of AlarmSettings with some convenience methods. */
class PUBLICTRANSPORTHELPER_EXPORT AlarmSettingsList : public QList< AlarmSettings > {
public:
    /** @brief Get a list of the names of all alarm settings in this list. */
    QStringList names() const;

    /** @brief Checks if there is an alarm settings object with the given @p name in this list. */
    bool hasName( const QString &name ) const;

    /**
     * @brief Gets the alarm settings object with the given @p name from this list.
     *
     * If there is no such alarm settings object, a default constructed AlarmSettings object
     * gets returned.
     **/
    AlarmSettings byName( const QString &name ) const;

    /** @brief Removes the alarm settings object with the given @p name from this list. */
    void removeByName( const QString &name );

    /** @brief Adds the given @p newAlarmSettings to this list or changes an existing one with
     * the same name, if there is already one in this list. */
    void set( const AlarmSettings &newAlarmSettings );
};

/** @brief Contains information about a color group configuration, ie. it's color. */
struct ColorGroupSettings {
    /**
     * @brief A list of filters for this color group configuration.
     *
     * Filters are OR combined while constraints are AND combined.
     * Departures/arrivals that match these filters are colored using the
     * coor of this ColorGroupSettings.
     **/
    FilterList filters;

    /**< @brief The color of this color group. */
    QColor color;

    /**< @brief Whether or not departures in this color group should be filtered out. */
    bool filterOut;

    QString lastCommonStopName;

    ColorGroupSettings( const QColor &color = Qt::transparent ) {
        this->color = color;
        this->filterOut = false;
    };

    /** @brief Applies the filters of this color group configuration
      * on the given @p departureInfo. */
    bool matches( const DepartureInfo& departureInfo ) const {
        return filters.match( departureInfo );
    };
};
bool operator ==( const ColorGroupSettings &l, const ColorGroupSettings &r );

/** @brief A list of ColorGroupSettings. */
class ColorGroupSettingsList : public QList< ColorGroupSettings > {
public:
    /** @brief Find a ColorGroupSettings object with the given @p color in the list. */
    ColorGroupSettings byColor( const QColor &color ) {
        foreach ( const ColorGroupSettings &colorSettings, *this ) {
            if ( colorSettings.color == color ) {
                return colorSettings;
            }
        }

        // No color group with the given color found, return an "empty" object
        return ColorGroupSettings();
    };

    void set( const ColorGroupSettings& newColorGroupSettings ) {
        for ( int i = 0; i < count(); ++i ) {
            if ( operator[](i).color == newColorGroupSettings.color ) {
                operator[]( i ) = newColorGroupSettings;
                return;
            }
        }

        // No color group with the given color found, add newColorGroupSettings to this list
        *this << newColorGroupSettings;
    }

    /** @brief Checks if there is a color group settings object with the given @p color in this list. */
    bool hasColor( const QColor &color ) const {
        for ( int i = 0; i < count(); ++i ) {
            if ( operator[](i).color == color ) {
                return true;
            }
        }

        return false;
    };

    /** @brief Removes the color group settings object with the given @p color from this list. */
    bool removeColor( const QColor &color ) {
        for ( int i = 0; i < count(); ++i ) {
            if ( operator[](i).color == color ) {
                removeAt( i );
                return true;
            }
        }

        return false;
    };

    /** @brief Enables/disables the ColorGroupSettings object with the given @p color in the list. */
    void enableColorGroup( const QColor color, bool enable = true ) {
        for ( int i = 0; i < count(); ++i ) {
            if ( operator[](i).color == color ) {
                operator[](i).filterOut = !enable;
                return;
            }
        }
    };

    /**
     * @brief Applies the filters of the color group configurations in the list to @p departureInfo.
     *
     * @param departureInfo The departure to test.
     * @returns True, if the given @p departureInfo matches a filtered out color group in the list.
     *   False, otherwise.
     **/
    bool filterOut( const DepartureInfo& departureInfo ) const {
        foreach( const ColorGroupSettings &colorSettings, *this ) {
            if ( colorSettings.filterOut && colorSettings.matches(departureInfo) ) {
                return true;
            }
        }

        return false;
    };
};

inline uint qHash( const QStringList &key )
{
    uint result = 1;
    foreach ( const QString &k, key ) {
        result += qHash( k );
    }
    return result;
}

/**
 * @brief Manages the configuration dialog and synchronizes with Settings.
 *
 * Get the current settings in the dialog using settings(), changing the settings programatically
 * is only done class intern.
 **/
class SettingsUiManager : public QObject {
    Q_OBJECT

public:
    enum DeletionPolicy {
        DeleteWhenFinished,
        KeepWhenFinished
    };

    SettingsUiManager( const Settings &settings,
            Plasma::DataEngine *publicTransportEngine, Plasma::DataEngine *osmEngine,
            Plasma::DataEngine *favIconEngine, Plasma::DataEngine *geolocationEngine,
            KConfigDialog *parentDialog, DeletionPolicy deletionPolicy = DeleteWhenFinished );

    /** @brief Gets a Settings object with the current settings in the dialog. */
    Settings settings();

signals:
    void settingsAccepted( const Settings &settings );
    void settingsFinished();

public slots:
    void removeAlarms( const AlarmSettingsList &newAlarmSettings,
                       const QList<int> &removedAlarms );

protected slots:
    /** @brief The config dialog has been closed. */
    void configFinished();

    /** @brief Ok pressed in the config dialog. */
    void configAccepted();

    /** @brief Loads the given @p filterConfig into the dialog. */
    void loadFilterConfiguration( const QString &filterConfig );

    /** @brief Adds a new filter configuration. */
    void addFilterConfiguration();

    /** @brief Removes the current filter configuration. */
    void removeFilterConfiguration();

    /** @brief Renames the current filter configuration. */
    void renameFilterConfiguration();

    /** @brief The action of the current filter has been changed. */
    void filterActionChanged( int index );

    /** @brief The list of affected stops of a filter configuration has been changed. */
    void affectedStopsFilterChanged();

    void filtersChanged();
    void setFilterConfigurationChanged( bool changed = true );

    void exportFilterSettings();
    void importFilterSettings();

    /** @brief Another alarm has been selected. */
    void currentAlarmChanged( int row );

    /** @brief The add alarm button has been clicked. */
    void addAlarmClicked();

    /** @brief The remove alarm button has been clicked. */
    void removeAlarmClicked();

    /** @brief The rename alarm button has been clicked. */
    void renameAlarmClicked();

    /** @brief The current alarm has been changed. */
    void alarmChanged();

    /** @brief The type of the current alarm has been changed. */
    void currentAlarmTypeChanged( int index );

    /** @brief The list of affected stops of this alarm has been changed. */
    void affectedStopsAlarmChanged();

    /** @brief An alarm item has been changed, eg. it's text or checked state. */
    void alarmChanged( int index );

    /** @brief The list of stop settings has been changed. */
    void stopSettingsChanged();

    /** @brief A new stop has been added. */
    void stopSettingsAdded();

    /** @brief A stop has been removed. */
    void stopSettingsRemoved( QWidget *widget, int widgetIndex );

    /** @brief The used filter configuration has been changed in the "filter uses"
     * tab of the filters page. */
    void usedFilterConfigChanged( QWidget *widget );

protected:
    void setValuesOfAdvancedConfig( const Settings &settings );
    void setValuesOfFilterConfig();
    void setValuesOfAlarmConfig();
    void setValuesOfAppearanceConfig( const Settings &settings );

private:
    FilterSettings currentFilterSettings() const;
    AlarmSettings currentAlarmSettings( const QString &name = QString() ) const;
    int filterConfigurationIndex( const QString &filterConfig );
    void setAlarmTextColor( int index, bool hasAffectedStops = true ) const;
    void updateStopNamesInWidgets();

    DeletionPolicy m_deletionPolicy;
//     DataSourceTester *m_dataSourceTester; // Tests data sources
    KConfigDialog *m_configDialog; // Stored for the accessor info dialog as parent

    Ui::publicTransportConfig m_ui;
    Ui::publicTransportConfigAdvanced m_uiAdvanced;
    Ui::publicTransportAppearanceConfig m_uiAppearance;
    Ui::publicTransportFilterConfig m_uiFilter;
    Ui::alarmConfig m_uiAlarms;

    ServiceProviderModel *m_modelServiceProvider; // The model for the service provider combobox in the config dialog
    LocationModel *m_modelLocations; // The model for the location combobox in the config dialog
    Plasma::DataEngine::Data m_serviceProviderData; // Service provider information from the data engine
    QVariantHash m_locationData; // Location information from the data engine.

    StopListWidget *m_stopListWidget;
    Plasma::DataEngine *m_publicTransportEngine, *m_osmEngine,
            *m_favIconEngine, *m_geolocationEngine;

    int m_currentStopSettingsIndex;
    bool m_showHeader;
    bool m_hideColumnTarget;

    FilterSettingsList m_filterSettings;
    QString m_lastFilterConfiguration; // The last set filter configuration
    bool m_filterConfigChanged; // Whether or not the filter configuration has changed from that defined in the filter configuration with the name [m_lastFilterConfiguration]

    QList<ColorGroupSettingsList> m_colorGroupSettings;

    AlarmSettingsList m_alarmSettings;
    int m_lastAlarm;
    bool m_alarmsChanged;
};

/**
 * @brief Contains static methods to read/write settings.
 *
 * Stop and filter settings are stored globally for all PublicTransport applets.
 **/
class SettingsIO {
public:
    /** @brief These flags describe what settings have changed. */
    enum ChangedFlag {
        NothingChanged          = 0x0000, /**< Nothing has changed. */
        IsChanged               = 0x0001, /**< This flag is set if something has changed.
                * If another change flag is set (except for NothingChanged), this flag is also
                * set. This flag also gets set for changes not covered by the other change flags. */
        ChangedServiceProvider  = 0x0002, /**< Service provider settings have been changed
                                            * (stop name, service provider, ...). */ // TODO
        ChangedDepartureArrivalListType
                                = 0x0004, /**< Changed from showing departures to arrivals
                                            * or vice versa. */
        ChangedStopSettings     = 0x0008, /**< Stop settings have been changed. This flag also gets
                * set if only eg. the favorite/recent journey searches have been changed.
                * Use ChangedCurrentStopSettings to check if timetable data needs to be requested
                * from the data engine again with the changed settings. */
        ChangedCurrentStopSettings
                                = 0x0010, /**< Stop settings of the current stop
                * have been changed, that require timetable data to be requested from the data
                * engine again. If this flag is set, the current timetable data may not represent
                * correct results any longer for the changed stop settings.
                * Stop settings that do not require a new timetable data request are unaffected. */
        ChangedCurrentJourneySearchLists
                                = 0x0020, /**< The list of favorite and/or recent journey
                                            * searches has been changed for the current stop. */
        ChangedCurrentStop      = 0x0040, /**< The current stop has been changed. */
        ChangedFilterSettings   = 0x0080, /**< Filter settings have been changed. */
        ChangedLinesPerRow      = 0x0100, /**< The lines per row setting has been changed. */
        ChangedAlarmSettings    = 0x0200, /**< Alarm settings have been changed. This does not
                                            * include AlarmTimeSetting in stop settings. */
        ChangedColorization     = 0x0400, /**< Colorization of departures has been toggled. */
        ChangedColorGroupSettings
                                = 0x0800  /**< Color group settings have been changed. */
    };
    Q_DECLARE_FLAGS( ChangedFlags, ChangedFlag );

    /** @brief Read settings from @p cg and @p cgGlobal. */
    static Settings readSettings( KConfigGroup cg, KConfigGroup cgGlobal,
                                  Plasma::DataEngine *publicTransportEngine = 0 );

    /**
     * @brief Decodes journey search items from @p data.
     *
     * @param data Journey search items encoded using encodeJourneySearchItems.
     * @return The list of journey search items decoded from @p data.
     * @see encodeJourneySearchItems
     **/
    static QList<JourneySearchItem> decodeJourneySearchItems( QByteArray *data );

    /**
     * @brief Encodes @p journeySearches into a QByteArray.
     *
     * @param journeySearches Journey search items to encode.
     * @return @p journeySearches encoded in a QByteArray.
     * @see decodeJourneySearchItems
     **/
    static QByteArray encodeJourneySearchItems( const QList<JourneySearchItem> &journeySearches );

    /**
     * @brief Write changed @p settings to @p cg and @p cgGlobal.
     *
     * @p oldSettings is used to see which settings have been changed.
     *
     * @returns What settings have been changed.
     * @see ChangedFlags */
    static ChangedFlags writeSettings( const Settings &settings, const Settings &oldSettings,
                                    KConfigGroup cg, KConfigGroup cgGlobal );

    /** @brief Read filter configuration from @p cgGlobal. */
    static FilterSettings readFilterConfig( const KConfigGroup &cgGlobal );

    static bool writeFilterConfig( const FilterSettings &filterSettings,
            const FilterSettings &oldFilterSettings, KConfigGroup cgGlobal );

    /** @brief Write filter configuration @p filterSettings to @p cgGlobal. */
    static void writeFilterConfig( const FilterSettings &filterSettings, KConfigGroup cgGlobal );
};
Q_DECLARE_OPERATORS_FOR_FLAGS( SettingsIO::ChangedFlags );

/**
 * @brief Contains all settings of the PublicTransport applet.
 *
 * Use SettingsIO to read/write settings from/to disk, use SettingsUiManager to synchronize and
 * connect the settings in this class with the widget states in the configuration dialog.
 **/
struct Settings {
public:
    /** @brief Creates a new Settings object. */
    Settings();

    /** @brief Copy constructor. */
    Settings( const Settings &other );

    /** @brief Destructor. */
    virtual ~Settings();

    /** @brief A list of all stop settings. */
    StopSettingsList stopSettingsList;

    /** @brief A list of all filter settings. */
    FilterSettingsList filterSettingsList;

    /** @brief A list of all alarm settings. */
    AlarmSettingsList alarmSettings;

    /**
     * @brief A list of all color group settings lists (one list for each stop).
     *
     * @note If colorize is false these color groups won't be used.
     **/
    QList<ColorGroupSettingsList> colorGroupSettingsList;

    /** @brief Whether or not departures should be colorized by groups. */
    bool colorize;

    /**
     * @brief The index of the currently used stop settings.
     *
     * Use currentStopSettings() to get the StopSettings object, this index is pointing at. If
     * isCurrentStopSettingsIndexValid() returns false, this index is not in the range of
     * available stop settings.
     *
     * @see currentStopSettings
     * @see isCurrentStopSettingsIndexValid
     **/
    int currentStopSettingsIndex;

    /** @brief Whether or not timetable data should be updated automatically. */
    bool autoUpdate;

    /** @brief Whether or not remaining minutes until departure/arrival should be shown. */
    bool showRemainingMinutes;

    /** @brief Whether or not departure times should be shown in the default timetable view. */
    bool showDepartureTime;

    /** @brief How many lines each row in the departure/arrival view should have. */
    int linesPerRow;

    /** @brief The maximal number of displayed departures. */
    int maximalNumberOfDepartures;

    /**
     * @brief A zoom factor to use for item/font sizes.
     *
     * This value gets stored and configured in the dialog as integer. This integer gets converted
     * to the size factor using sizeFactorFromSize. To convert back sizeFromSizeFactor is used.
     **/
    float sizeFactor;

    /**
     * @brief The type of data to be shown in the default timetable view.
     *
     * The default timetable view can show either departures or arrivals.
     **/
    DepartureArrivalListType departureArrivalListType;

    /** @brief Whether or not shadows should be drawn in the applet. */
    bool drawShadows;

    /** @deprecated Whether or not the header of the departure view should be shown. */
    bool showHeader;

    /** @brief Whether or not the target/origin column should be shown in the departure view. */
    bool hideColumnTarget;

    /** @brief Whether or not departure/arrival times should be displayed bold in the timetable. */
    bool displayTimeBold;

    /** @brief Whether or not the default plasma theme's font is used. */
    bool useDefaultFont;

    /**
     * @brief The font to be used in the applet.
     *
     * This font gets only used, if useDefaultFont is false.
     * @note If the font size is smaller than the font size of KGlobalSettings::smallestReadableFont
     *   that smallest readable font gets used instead to ensure best possible readability.
     **/
    QFont font;

    /** @brief Gets font with the size zoomed by sizeFactor. */
    QFont sizedFont() const {
        QFont f = font;
        if ( f.pointSize() == -1 ) {
            int pixelSize = f.pixelSize() * sizeFactor;
            f.setPixelSize( pixelSize > 0 ? pixelSize : 1 );
        } else {
            int pointSize = f.pointSize() * sizeFactor;
            f.setPointSize( pointSize > 0 ? pointSize : 1 );
        }
        return f;
    };

    /**
     * @brief Gets the size factor to be used for the given @p size value.
     *
     * @param size An integer value, ie. configurable using a slider widget. Smallest value is null.
     * @return The size factor associated with the given @p size value.
     **/
    static inline qreal sizeFactorFromSize( int size ) { return (size + 3) * 0.2; };

    /**
     * @brief Gets the integer size value to be used for the given @p sizeFactor.
     *
     * @param sizeFactor The zoom factor, to get the integer size value for.
     * @return The size associated with the given @p sizeFactor.
     **/
    static inline int sizeFromSizeFactor( qreal sizeFactor ) { return qRound(sizeFactor / 0.2) - 3; };

    /**
     * @brief Gets the currently used stop settings.
     *
     * If the current stop settings index is invalid an empty StopSettings object gets returned.
     * @see isCurrentStopSettingsIndexValid
     **/
    const StopSettings currentStopSettings() const {
        if ( !isCurrentStopSettingsIndexValid() ) {
            kDebug() << "Current stop index invalid" << currentStopSettingsIndex
                     << "Stop settings count:" << stopSettingsList.count();
            return StopSettings();
        }
        return stopSettingsList[ currentStopSettingsIndex ];
    };

    /**
     * @brief Gets a reference to the currently used stop settings.
     *
     * The returned StopSettings object can be used to also directly change the settings
     * in this class.
     *
     * @warning This crashes with invalid stop settings index.
     * @see isCurrentStopSettingsIndexValid
     **/
    StopSettings &currentStopSettings() {
        Q_ASSERT_X( isCurrentStopSettingsIndexValid(), "StopSettings::currentStopSettings",
                    QString("There's no stop settings with index %1 to get a "
                            "reference to").arg(currentStopSettingsIndex).toLatin1() );
        return stopSettingsList[ currentStopSettingsIndex ];
    };

    /** @brief Whether or not the index of the currently used stop settings is valid. */
    bool isCurrentStopSettingsIndexValid() const {
        return currentStopSettingsIndex >= 0 && currentStopSettingsIndex < stopSettingsList.count();
    };

    /** @brief Gets a list of JourneySearchItem's for the current stop settings. */
    QList<JourneySearchItem> currentJourneySearches() const {
        return currentStopSettings().get< QList<JourneySearchItem> >( UserSetting );
    };

    /** @brief Sets a list of JourneySearchItem's for the current stop settings. */
    void setCurrentJourneySearches( const QList<JourneySearchItem> &journeySearches ) {
        StopSettings &stopSettings = currentStopSettings();
        stopSettings.set( UserSetting, QVariant::fromValue(journeySearches) );
    };

    /**
     * @brief Gets a list of all currently active filter settings.
     *
     * Filter settings are "active", if they are set to be used by the currently selected
     * stop settings.
     **/
    FilterSettingsList currentFilterSettings() const {
        // Construct filter settings per stop (constructed of multiple filter configs)
        FilterSettingsList activeFilterSettings;
        foreach ( const FilterSettings &filterSettings, filterSettingsList ) {
            if ( filterSettings.affectedStops.contains(currentStopSettingsIndex) ) {
                activeFilterSettings << filterSettings;
            }
        }
        return activeFilterSettings;
    };

    /**
     * @brief Gets a list of all currently active color group settings.
     *
     * Color group settings are "active", if their associated stop is currently selected.
     **/
    ColorGroupSettingsList currentColorGroupSettings() const {
        if ( currentStopSettingsIndex < 0
             || currentStopSettingsIndex >= colorGroupSettingsList.count() )
        {
            return ColorGroupSettingsList();
        } else {
            return colorGroupSettingsList[ currentStopSettingsIndex ];
        }
    };

    /** @brief Favorize the given @p journeySearch.*/
    void favorJourneySearch( const QString &journeySearch );

    /** @brief Removes the given @p journeySearch from the list of favored/recent journey searches. */
    void removeJourneySearch( const QString &journeySearch );

    /**
     * @brief Add the given @p journeySearch to the list of recent journey searches.
     *
     * If @p journeySearch is a favored journey search, this function does nothing.
     **/
    void addRecentJourneySearch( const QString &journeySearch );

    bool checkConfig() {
        // TODO: Check when adding stops in StopSettingsDialog
        if ( stopSettingsList.isEmpty() ) {
            return false;
        } else {
            foreach ( const StopSettings &stopSettings, stopSettingsList ) {
                if ( stopSettings.stops().isEmpty() ) {
                    return false;
                } else {
                    foreach ( const QString &stop, stopSettings.stops() ) {
                        if ( stop.isEmpty() ) {
                            return false;
                        }
                    }
                }
            }
        }
        return true;

        //     if ( m_useSeparateCityValue && (m_city.isEmpty()
        //         || m_stops.isEmpty() || m_stops.first().isEmpty()) )
        //     emit configurationRequired(true, i18n("Please set a city and a stop."));
        //     else if ( m_stops.isEmpty() || m_stops.first().isEmpty() )
        //     emit configurationRequired(true, i18n("Please set a stop."));
        //     else if ( m_serviceProvider == "" )
        //     emit configurationRequired(true, i18n("Please select a service provider."));
        //     else {
        //     emit configurationRequired(false);
        //     return true;
        //     }
        //
        //     return false;
    };
};

#endif // SETTINGS_HEADER
