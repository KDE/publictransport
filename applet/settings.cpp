/*
 *   Copyright 2011 Friedrich PÃ¼lz <fpuelz@gmx.de>
 *
 *   This program is free software; you can redistribute it and/or modify
 *   it under the terms of the GNU Library General Public License as
 *   published by the Free Software Foundation; either version 2 or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details
 *
 *   You should have received a copy of the GNU Library General Public
 *   License along with this program; if not, write to the
 *   Free Software Foundation, Inc.,
 *   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

// Own includes
#include "settings.h"

Settings::Settings()
{
    currentStopSettingsIndex = 0;
}

Settings::Settings( const Settings& other )
{
    *this = other;
}

Settings::~Settings()
{
}

void Settings::favorJourneySearch( const QString &journeySearch )
{
    QList< JourneySearchItem > journeySearches = currentJourneySearches();
    for ( int i = 0; i < journeySearches.count(); ++i ) {
        if ( journeySearches[i].journeySearch() == journeySearch ) {
            journeySearches[i].setFavorite( true );
            setCurrentJourneySearches( journeySearches );
            break;
        }
    }
}

void Settings::removeJourneySearch( const QString &journeySearch )
{
    QList< JourneySearchItem > journeySearches = currentJourneySearches();
    for ( int i = 0; i < journeySearches.count(); ++i ) {
        if ( journeySearches[i].journeySearch() == journeySearch ) {
            journeySearches.removeAt( i );
            setCurrentJourneySearches( journeySearches );
            break;
        }
    }
}

void Settings::addRecentJourneySearch( const QString &journeySearch )
{
    QList< JourneySearchItem > journeySearches = currentJourneySearches();
    for ( int i = 0; i < journeySearches.count(); ++i ) {
        if ( journeySearches[i].journeySearch() == journeySearch ) {
            // Do not add already existing journey search strings
            return;
        }
    }

    // The given journeySearch string is not already in journeySearches, add it
    journeySearches << JourneySearchItem( journeySearch );
    setCurrentJourneySearches( journeySearches );
}

bool AlarmSettings::equalsAutogeneratedAlarm( const AlarmSettings& other ) {
    if ( !autoGenerated || !other.autoGenerated || type != other.type
            || enabled != other.enabled )
    {
        return false;
    }

    Filter alarmFilter = filter;
    for ( int i = 0; i < alarmFilter.count(); ++i ) {
        if ( alarmFilter[i].type == Timetable::FilterByTarget ) {
            alarmFilter.removeAt( i );
            break;
        }
    }

    return alarmFilter == other.filter;
}

QStringList AlarmSettingsList::names() const {
    QStringList ret;
    foreach ( const AlarmSettings &alarmSettings, *this ) {
        ret << alarmSettings.name;
    }
    return ret;
}

bool AlarmSettingsList::hasName( const QString& name ) const {
    foreach ( const AlarmSettings &alarmSettings, *this ) {
        if ( alarmSettings.name == name ) {
            return true;
        }
    }
    return false; // No alarm with the given name found
}

AlarmSettings AlarmSettingsList::byName( const QString& name ) const {
    foreach ( const AlarmSettings &alarmSettings, *this ) {
        if ( alarmSettings.name == name ) {
            return alarmSettings;
        }
    }
    return AlarmSettings(); // No alarm with the given name found
}

void AlarmSettingsList::removeByName( const QString& name ) {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).name == name ) {
            removeAt( i );
            return;
        }
    }

    kDebug() << "No alarm with the given name found:" << name;
    kDebug() << "Available names are:" << names();
}

void AlarmSettingsList::set( const AlarmSettings& newAlarmSettings ) {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).name == newAlarmSettings.name ) {
            operator[]( i ) = newAlarmSettings;
            return;
        }
    }

    // No alarm with the given name found, add newAlarmSettings to this list
    *this << newAlarmSettings;
}

bool operator ==( const AlarmSettings &l, const AlarmSettings &r )
{
    return l.name == r.name && l.enabled == r.enabled && l.type == r.type
        && l.affectedStops == r.affectedStops && l.filter == r.filter
        && l.lastFired == r.lastFired;
}

bool operator==( const ColorGroupSettings &l, const ColorGroupSettings &r )
{
    return l.color == r.color && l.filters == r.filters && l.filterOut == r.filterOut
        && l.lastCommonStopName == r.lastCommonStopName;
}

ColorGroupSettings ColorGroupSettingsList::byColor( const QColor &color ) {
    foreach ( const ColorGroupSettings &colorSettings, *this ) {
        if ( colorSettings.color == color ) {
            return colorSettings;
        }
    }

    // No color group with the given color found, return an "empty" object
    return ColorGroupSettings();
}

void ColorGroupSettingsList::set( const ColorGroupSettings &newColorGroupSettings ) {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).color == newColorGroupSettings.color ) {
            operator[]( i ) = newColorGroupSettings;
            return;
        }
    }

    // No color group with the given color found, add newColorGroupSettings to this list
    *this << newColorGroupSettings;
}

bool ColorGroupSettingsList::hasColor( const QColor &color ) const {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).color == color ) {
            return true;
        }
    }

    return false;
}

bool ColorGroupSettingsList::removeColor( const QColor &color ) {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).color == color ) {
            removeAt( i );
            return true;
        }
    }

    return false;
}

void ColorGroupSettingsList::enableColorGroup( const QColor &color, bool enable ) {
    for ( int i = 0; i < count(); ++i ) {
        if ( operator[](i).color == color ) {
            operator[](i).filterOut = !enable;
            return;
        }
    }
}

bool ColorGroupSettingsList::filterOut( const Timetable::DepartureInfo &departureInfo ) const {
    foreach( const ColorGroupSettings &colorSettings, *this ) {
        if ( colorSettings.filterOut && colorSettings.matches(departureInfo) ) {
            return true;
        }
    }

    return false;
}

void Settings::adjustColorGroupSettingsCount()
{
    while ( colorGroupSettingsList.count() < stopSettingsList.count() ) {
        colorGroupSettingsList << ColorGroupSettingsList();
    }
    while ( colorGroupSettingsList.count() > stopSettingsList.count() ) {
        colorGroupSettingsList.removeLast();
    }
}
